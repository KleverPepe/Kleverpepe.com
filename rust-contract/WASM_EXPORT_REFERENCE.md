# Klever-SC WASM Export Pattern Reference

## Executive Summary

The **klever-sc** framework automatically exports contract endpoints to WebAssembly through a **two-stage code generation system**:
1. **Macro-based generation** (compile-time) - Uses `#[klever_sc::contract]` and `#[endpoint]` macros
2. **Meta build system** (build-time) - The `meta` crate generates the actual WASM entry points via the `klever_sc_wasm_adapter::endpoints!` macro

**No manual `#[export]` or `#[wasm_bindgen]` declarations are needed** - the framework handles it automatically.

---

## 1. Macro Pattern: The Key Export Mechanism

### The Answer: `klever_sc_wasm_adapter::endpoints!` Macro

The critical macro that bridges contract endpoints to WASM is:

```rust
klever_sc_wasm_adapter::endpoints! {
    contract_module_name
    (
        init => init
        endpoint1_name => endpoint1_rust_name
        endpoint2_name => endpoint2_rust_name
        // ... more endpoints
    )
}
```

This macro is **automatically generated** in `wasm/src/lib.rs` (the WASM crate).

### Example from hello-world:
**Contract definition** (src/lib.rs):
```rust
#[klever_sc::contract]
pub trait HelloWorld: ContractBase {
    #[init]
    fn init(&self) {}

    #[endpoint]
    fn get_message(&self) {
        self.message("Hello World!");
    }

    #[endpoint]
    #[payable("KLV")]
    fn pay_hello(&self) {
        // ...
    }
}
```

**Generated WASM crate** (wasm/src/lib.rs - AUTO-GENERATED):
```rust
// Code generated by the klever-sc build system. DO NOT EDIT.

// Init:                                 1
// Endpoints:                            2
// Total number of exported functions:   3

#![no_std]

klever_sc_wasm_adapter::allocator!();
klever_sc_wasm_adapter::panic_handler!();

klever_sc_wasm_adapter::endpoints! {
    hello_world
    (
        init => init
        get_message => get_message
        pay_hello => pay_hello
    )
}
```

---

## 2. How The Macro Works (Under the Hood)

The `endpoints!` macro expands to:
```rust
#[no_mangle]
fn init() {
    hello_world::endpoints::init::<klever_sc_wasm_adapter::api::VmApiImpl>();
}

#[no_mangle]
fn get_message() {
    hello_world::endpoints::get_message::<klever_sc_wasm_adapter::api::VmApiImpl>();
}

#[no_mangle]
fn pay_hello() {
    hello_world::endpoints::pay_hello::<klever_sc_wasm_adapter::api::VmApiImpl>();
}
```

The `#[no_mangle]` attribute ensures these functions are exported as WASM module functions with predictable names.

---

## 3. Required Declarations in Contract Code

Only three things are needed:

### 1. Contract Trait Declaration
```rust
#[klever_sc::contract]
pub trait MyContract: ContractBase {
    // ...
}
```

### 2. Initialize with `#[init]`
```rust
#[init]
fn init(&self) {
    // initialization code
}
```

### 3. Mark Public Functions with `#[endpoint]` or `#[view]`
```rust
#[endpoint]
fn my_endpoint(&self, arg: u32) {
    // endpoint code
}

#[view]
fn my_view(&self) -> u32 {
    // view code - read-only
}
```

**NO `#[export]`, `#[wasm_bindgen]`, or `#[no_mangle]` needed** - the build system handles it all!

---

## 4. The Three-Layer Architecture

### Layer 1: Contract Crate (lib.rs)
- Contains the trait definition with endpoints
- Decorated with `#[klever_sc::contract]`, `#[endpoint]`, `#[view]`, `#[init]`
- `#[klever_sc::contract]` macro generates an `AbiProvider` implementation

### Layer 2: Meta Crate (meta/src/main.rs)
- Minimal code required:
```rust
fn main() {
    klever_sc_meta::cli_main::<my_contract::AbiProvider>();
}
```
- Extracts contract metadata via `ContractAbiProvider` trait
- Reads configuration from `kleverchain.json` or `multicontract.toml`
- Generates the ABI JSON
- **Generates the WASM crate code** including `wasm/src/lib.rs`

### Layer 3: WASM Crate (wasm/src/lib.rs)
- **Completely auto-generated** - DO NOT EDIT
- Contains the `klever_sc_wasm_adapter::endpoints!` macro invocation
- Gets compiled to WebAssembly binary
- Entry point for the WASM runtime

---

## 5. Build Process Flow

```
1. Compile contract crate
   ↓
2. Macros generate AbiProvider
   ↓
3. Run meta crate: cargo run --manifest-path meta/Cargo.toml build
   ↓
4. Meta crate calls AbiProvider to get contract metadata
   ↓
5. Parse kleverchain.json/multicontract.toml
   ↓
6. Generate wasm/src/lib.rs with endpoints! macro
   ↓
7. Generate output/*.kleversc.json ABI file
   ↓
8. Compile wasm crate to WebAssembly
   ↓
9. Output:
   - contract.wasm (binary)
   - contract.kleversc.json (ABI + metadata)
   - contract.wat (optional text format)
   - contract.imports.json (optional imports)
```

---

## 6. Build Configuration Files

### kleverchain.json or multicontract.toml

Located at contract root. Example for single contract:
```toml
[build]
# No special configuration needed for basic case
```

For explicit output naming:
```toml
[[contracts]]
name = "kpepe-jackpot"
```

---

## 7. ABI Generation & Metadata

The build system generates `.kleversc.json` files containing:

```json
{
  "buildInfo": {
    "rustc": { "version": "...", "channel": "..." },
    "contractCrate": { "name": "...", "version": "..." },
    "framework": { "name": "klever-sc", "version": "..." }
  },
  "abi": {
    "docs": [...],
    "endpoints": [
      {
        "name": "init",
        "mutability": "mutable",
        "inputs": [],
        "outputs": []
      },
      {
        "name": "initialize_wallets",
        "mutability": "mutable",
        "inputs": [...],
        "outputs": []
      }
    ]
  },
  "size": 12345,
  "code": "0x00010203..."  // hex-encoded WASM binary
}
```

---

## 8. Your Current Project Status

Looking at your `lib.rs`:

```rust
#[klever_sc::contract]
pub trait KPEPEJackpot: ContractBase {
    #[init]
    fn init(&self) { ... }

    #[endpoint]
    fn initialize_wallets(&self, ...) { ... }

    #[endpoint]
    fn toggle_round(&self) { ... }

    #[view]
    fn get_pool_balance(&self) -> BigUint { ... }
}
```

✅ **This is exactly correct!** All your endpoints are properly decorated.

**What's missing:** The `wasm/` crate is not generated. You need:

1. Ensure you have a `meta` folder with build infrastructure
2. Run: `cd meta && cargo run build` (or `sc-meta all build` if installed)
3. This will generate `wasm/src/lib.rs` and `output/kpepe_jackpot.kleversc.json`

---

## 9. Special Cases

### External View Contracts (Read-Only)
Use `#[external_view]` setting in config:
```rust
klever_sc_wasm_adapter::external_view_init! {}
klever_sc_wasm_adapter::external_view_endpoints! {
    contract_name
    (
        endpoint1 => endpoint1
    )
}
```

### Modules
Modules are handled automatically via `#[klever_sc::module]`:
```rust
#[klever_sc::module]
pub trait MyModule {
    #[endpoint]
    fn module_endpoint(&self) { ... }
}
```

All module endpoints are collected and included in the final WASM export list.

---

## 10. Key Differences from Other WASM Frameworks

| Aspect | klever-sc | wasm-bindgen |
|--------|-----------|-------------|
| **Export Declaration** | `#[endpoint]` macro | `#[wasm_bindgen]` attribute |
| **WASM Entry Points** | Auto-generated via meta crate | Manual or automatic |
| **ABI Generation** | Built-in (produces .kleversc.json) | Via tools |
| **Function Mapping** | `endpoints!` macro | Direct wasm-bindgen |
| **Contract Logic Crate** | Pure Rust, no WASM knowledge | WASM-aware |
| **Separate WASM Crate** | Yes (cleaner separation) | Optional |

---

## 11. Troubleshooting

### Endpoints not showing in WASM
- Ensure function has `#[endpoint]` or `#[view]` decorator
- Check `kleverchain.json`/`multicontract.toml` configuration
- Rebuild via meta crate: `cd meta && cargo run build`

### .kleversc.json not generated
- Ensure meta crate exists with proper `main.rs`
- Run: `sc-meta all build` (requires installing `klever-sc-meta`)

### wasm/src/lib.rs is stale
- Delete it and rebuild - it's auto-generated
- Never edit it manually

---

## 12. Example: Complete Build Flow

```bash
# 1. Define contract (already done)
# src/lib.rs has #[klever_sc::contract], #[endpoint], etc.

# 2. Ensure WASM crate exists
ls wasm/Cargo.toml  # Should exist

# 3. Build via meta crate
cd meta
cargo run build

# 4. Outputs created:
# - wasm/src/lib.rs (auto-generated)
# - output/kpepe_jackpot.wasm
# - output/kpepe_jackpot.kleversc.json
# - output/kpepe_jackpot.imports.json (optional)

# 5. Deploy the .wasm binary to blockchain
```

---

## 13. References

- **Framework Docs**: https://docs.klever.org/smart-contracts/
- **Build Reference**: https://docs.klever.org/smart-contracts/config-and-tooling/build-reference
- **GitHub Examples**: https://github.com/klever-io/klever-vm-sdk-rs/tree/main/contracts/examples
- **Hello World Example**: https://github.com/klever-io/klever-vm-sdk-rs/tree/main/contracts/examples/hello-world
- **Crowdfunding Example**: https://github.com/klever-io/klever-vm-sdk-rs/tree/main/contracts/examples/crowdfunding-kda

---

## Summary

**The klever-sc framework exports endpoints to WASM through automatic code generation:**

1. ✅ You mark endpoints with `#[endpoint]` or `#[view]`
2. ✅ No `#[export]` or `#[wasm_bindgen]` needed
3. ✅ Meta crate extracts contract metadata at build-time
4. ✅ Generates `wasm/src/lib.rs` with `klever_sc_wasm_adapter::endpoints!` macro
5. ✅ Produces `.kleversc.json` containing ABI and compiled WASM code
6. ✅ The macro expansion creates `#[no_mangle]` WASM functions for each endpoint

**For your KPEPE contract:** Your endpoint definitions are perfect. Just ensure the build infrastructure is set up and run the meta crate build command.
