{
  "contract": "KPEPEJackpot",
  "version": "1.0.0",
  "timestamp": "2026-01-27T16:51:21.133Z",
  "code": "/**\n * KPEPE Jackpot Lottery - JavaScript for KleverChain\n * Based on original Solidity contract\n * \n * DEPLOYMENT INSTRUCTIONS:\n * 1. Go to kleverscan.org/contracts\n * 2. Click \"Deploy Contract\"\n * 3. Upload this file as the contract code\n * 4. Set Gas Limit: 3,000,000\n * 5. Connect wallet and deploy\n */\n\n// Reentrancy Guard\nconst REENTRANCY_GUARD = {\n    locked: false,\n    \n    lock() {\n        if (this.locked) {\n            throw new Error('Reentrant call detected');\n        }\n        this.locked = true;\n    },\n    \n    unlock() {\n        this.locked = false;\n    }\n};\n\n// Cryptographically secure random number generator\nfunction secureRandom(seed) {\n    const x = Math.sin(seed++) * 10000;\n    return Math.floor((x - Math.floor(x)) * 1000000);\n}\n\n// Seed generator from multiple sources\nfunction generateSeed(blockchain) {\n    const sources = [\n        blockchain.timestamp,\n        blockchain.caller.charCodeAt(0),\n        Math.floor(Math.random() * 1000000),\n        Date.now(),\n        process.hrtime ? process.hrtime()[0] : 0\n    ];\n    \n    let seed = 0;\n    for (const s of sources) {\n        seed = ((seed << 5) - seed) + s;\n        seed = seed & seed; // Keep as integer\n    }\n    return Math.abs(seed);\n}\n\nclass KPEPEJackpot {\n    constructor(blockchain) {\n        this.blockchain = blockchain;\n        \n        // Constants\n        this.TICKET_PRICE = 10000000000; // 100 KLV (8 decimals)\n        this.MAIN_COUNT = 5;\n        this.EIGHT_RANGE = 20;\n        this.MAIN_RANGE = 50;\n        \n        // Prize percentages (basis points)\n        this.PRIZE_JACKPOT = 4000;\n        this.PRIZE_MATCH5 = 1500;\n        this.PRIZE_4_8B = 800;\n        this.PRIZE_4 = 500;\n        this.PRIZE_3_8B = 600;\n        this.PRIZE_3 = 450;\n        this.PRIZE_2_8B = 300;\n        this.PRIZE_1_8B = 150;\n        this.PRIZE_8B_ONLY = 125;\n        this.POOL_RETENTION = 1975;\n        this.MAX_POOL = 100000000000000; // 1M KLV\n        \n        this.MIN_STAKE_FOR_FREE = 5000000000000; // 50K KPEPE\n        this.FREE_TICKETS_PER_DAY = 1;\n        \n        // Storage\n        this.storage = {\n            projectWallet: '',\n            prizePoolWallet: '',\n            kpepeToken: '',\n            kpepeStaking: '',\n            prizePool: 0,\n            totalTicketsSold: 0,\n            lastDrawTime: 0,\n            drawInProgress: false,\n            roundActive: true,\n            winningNumbers: [0, 0, 0, 0, 0],\n            winningEightBall: 0,\n            kpepeJackpotPrize: 0,\n            kpepeMatch5Prize: 0,\n            kpepeMatch48BPrize: 0,\n            kpepeMatch4Prize: 0,\n            kpepeMatch38BPrize: 0,\n            kpepeMatch3Prize: 0,\n            kpepeMatch28BPrize: 0,\n            kpepeMatch18BPrize: 0,\n            kpepeMatch8BOnlyPrize: 0,\n            // Commit-reveal scheme for tickets\n            ticketCommits: {}, // hash -> {nums, eb, revealTime, player}\n            revealDelay: 2, // blocks\n        };\n        \n        // State\n        this.tickets = [];\n        this.playerTicketIds = {};\n        this.kpepePrizesPending = {};\n        this.freeTicketCredits = {};\n        this.lastFreeTicketClaim = {};\n        this.freeTicketPlayers = [];\n        this.isFreeTicketPlayer = {};\n        \n        // Reentrancy guard for this contract\n        this._inFunction = {};\n    }\n    \n    require(condition, message) {\n        if (!condition) {\n            throw new Error(message || 'Requirement failed');\n        }\n    }\n    \n    // Reentrancy guard modifier\n    nonReentrant(functionName) {\n        if (this._inFunction[functionName]) {\n            throw new Error('Reentrant call not allowed');\n        }\n        this._inFunction[functionName] = true;\n        return () => { this._inFunction[functionName] = false; };\n    }\n    \n    init() {\n        this.storage.lastDrawTime = this.blockchain.timestamp;\n        this.storage.roundActive = true;\n    }\n    \n    /**\n     * Commit phase for ticket purchase (prevents frontrunning)\n     * @param {string} commitHash - Hash of (nums, eb, salt)\n     */\n    commitTicket(commitHash) {\n        const caller = this.blockchain.caller;\n        \n        this.require(this.storage.roundActive, 'Round not active');\n        this.require(!this.storage.ticketCommits[commitHash], 'Commit already exists');\n        \n        // Store commit without revealing numbers\n        this.storage.ticketCommits[commitHash] = {\n            player: caller,\n            commitTime: this.blockchain.timestamp,\n            revealed: false\n        };\n        \n        this.blockchain.emit('TicketCommitted', { player: caller, commitHash });\n    }\n    \n    /**\n     * Reveal phase for ticket purchase\n     * @param {number[]} nums - 5 main numbers (1-50)\n     * @param {number} eb - Eight ball number (1-20)\n     * @param {string} salt - Salt used in commit\n     */\n    revealTicket(nums, eb, salt) {\n        const caller = this.blockchain.caller;\n        \n        this.require(this.storage.roundActive, 'Round not active');\n        this.require(eb >= 1 && eb <= this.EIGHT_RANGE, 'Eight ball 1-20');\n        \n        // Validate numbers\n        for (let i = 0; i < this.MAIN_COUNT; i++) {\n            this.require(nums[i] >= 1 && nums[i] <= this.MAIN_RANGE, 'Numbers 1-50');\n            for (let j = i + 1; j < this.MAIN_COUNT; j++) {\n                this.require(nums[i] !== nums[j], 'Duplicate numbers');\n            }\n        }\n        \n        // Verify commit exists\n        const commitHash = this.hashCommit(nums, eb, salt);\n        const commit = this.storage.ticketCommits[commitHash];\n        this.require(commit, 'Commit not found');\n        this.require(commit.player === caller, 'Not your commit');\n        this.require(!commit.revealed, 'Already revealed');\n        \n        // Check delay (simulated - in real blockchain, check block number)\n        const timeSinceCommit = this.blockchain.timestamp - commit.commitTime;\n        this.require(timeSinceCommit >= this.storage.revealDelay * 15000, 'Reveal too soon'); // ~15s per block\n        \n        // Mark as revealed\n        commit.revealed = true;\n        commit.nums = nums;\n        commit.eb = eb;\n        \n        // Process payment (after commit-reveal)\n        let useFree = false;\n        if (this.freeTicketCredits[caller] > 0 && this.blockchain.value === 0) {\n            useFree = true;\n            this.freeTicketCredits[caller]--;\n        } else {\n            this.require(this.blockchain.value === this.TICKET_PRICE, 'Must send 100 KLV');\n        }\n        \n        let poolAmt = 0;\n        let projAmt = 0;\n        \n        if (!useFree) {\n            poolAmt = (this.TICKET_PRICE * 85) / 100;\n            projAmt = this.TICKET_PRICE - poolAmt;\n            \n            if (this.storage.prizePool + poolAmt > this.MAX_POOL) {\n                poolAmt = this.MAX_POOL - this.storage.prizePool;\n                projAmt = this.TICKET_PRICE - poolAmt;\n                this.blockchain.emit('PoolCapped', this.MAX_POOL);\n            }\n            \n            this.storage.prizePool += poolAmt;\n            \n            if (projAmt > 0 && this.storage.projectWallet) {\n                this.blockchain.transfer(this.storage.projectWallet, projAmt);\n            }\n        }\n        \n        // Create ticket\n        const ticket = {\n            player: caller,\n            mainNumbers: nums,\n            eightBall: eb,\n            purchaseTime: this.blockchain.timestamp,\n            hasWon: false,\n            prizeClaimed: false,\n            isFree: useFree,\n            commitHash: commitHash\n        };\n        \n        const id = this.tickets.length;\n        this.tickets.push(ticket);\n        \n        if (!this.playerTicketIds[caller]) {\n            this.playerTicketIds[caller] = [];\n        }\n        this.playerTicketIds[caller].push(id);\n        \n        this.storage.totalTicketsSold++;\n        \n        this.blockchain.emit('TicketRevealed', { id, player: caller, nums, eb, isFree: useFree });\n    }\n    \n    /**\n     * Generate commit hash from numbers, eb, and salt\n     */\n    hashCommit(nums, eb, salt) {\n        const data = JSON.stringify({ nums, eb, salt, player: this.blockchain.caller });\n        let hash = 0;\n        for (let i = 0; i < data.length; i++) {\n            const char = data.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash;\n        }\n        return '0x' + Math.abs(hash).toString(16).padStart(64, '0');\n    }\n    \n    /**\n     * Generate random numbers using secure RNG\n     */\n    generateSecureRandomNumbers() {\n        const seed = generateSeed(this.blockchain);\n        const nums = [];\n        const used = {};\n        \n        for (let i = 0; i < this.MAIN_COUNT; i++) {\n            let num;\n            do {\n                const rand = secureRandom(seed + i);\n                num = (rand % this.MAIN_RANGE) + 1;\n            } while (used[num]);\n            used[num] = true;\n            nums.push(num);\n        }\n        \n        nums.sort((a, b) => a - b);\n        \n        const eb = (secureRandom(seed + 100) % this.EIGHT_RANGE) + 1;\n        \n        return { nums, eb };\n    }\n    \n    /**\n     * Buy ticket with numbers (simplified - without commit-reveal for small purchases)\n     * @param {number[]} nums - 5 main numbers (1-50)\n     * @param {number} eb - Eight ball number (1-20)\n     */\n    buyTicket(nums, eb) {\n        const cleanup = this.nonReentrant('buyTicket');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(this.storage.roundActive, 'Round not active');\n            this.require(eb >= 1 && eb <= this.EIGHT_RANGE, 'Eight ball 1-20');\n            \n            // Validate numbers\n            for (let i = 0; i < this.MAIN_COUNT; i++) {\n                this.require(nums[i] >= 1 && nums[i] <= this.MAIN_RANGE, 'Numbers 1-50');\n                for (let j = i + 1; j < this.MAIN_COUNT; j++) {\n                    this.require(nums[i] !== nums[j], 'Duplicate numbers');\n                }\n            }\n            \n            let useFree = false;\n            \n            // Check free credits\n            if (this.freeTicketCredits[caller] > 0 && this.blockchain.value === 0) {\n                useFree = true;\n                this.freeTicketCredits[caller]--;\n            } else {\n                this.require(this.blockchain.value === this.TICKET_PRICE, 'Must send 100 KLV');\n            }\n            \n            let poolAmt = 0;\n            let projAmt = 0;\n            \n            if (!useFree) {\n                poolAmt = (this.TICKET_PRICE * 85) / 100;\n                projAmt = this.TICKET_PRICE - poolAmt;\n                \n                if (this.storage.prizePool + poolAmt > this.MAX_POOL) {\n                    poolAmt = this.MAX_POOL - this.storage.prizePool;\n                    projAmt = this.TICKET_PRICE - poolAmt;\n                    this.blockchain.emit('PoolCapped', this.MAX_POOL);\n                }\n                \n                this.storage.prizePool += poolAmt;\n                \n                if (projAmt > 0 && this.storage.projectWallet) {\n                    this.blockchain.transfer(this.storage.projectWallet, projAmt);\n                }\n            }\n            \n            // Create ticket\n            const ticket = {\n                player: caller,\n                mainNumbers: nums,\n                eightBall: eb,\n                purchaseTime: this.blockchain.timestamp,\n                hasWon: false,\n                prizeClaimed: false,\n                isFree: useFree\n            };\n            \n            const id = this.tickets.length;\n            this.tickets.push(ticket);\n            \n            if (!this.playerTicketIds[caller]) {\n                this.playerTicketIds[caller] = [];\n            }\n            this.playerTicketIds[caller].push(id);\n            \n            this.storage.totalTicketsSold++;\n            \n            this.blockchain.emit('TicketPurchased', { id, player: caller, nums, eb, isFree: useFree });\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Quick pick - uses secure random numbers\n     */\n    quickPick() {\n        const cleanup = this.nonReentrant('quickPick');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(this.storage.roundActive, 'Round not active');\n            \n            const { nums, eb } = this.generateSecureRandomNumbers();\n            \n            if (this.freeTicketCredits[caller] > 0 && this.blockchain.value === 0) {\n                this.freeTicketCredits[caller]--;\n                this.createFreeTicket(nums, eb);\n            } else {\n                this.require(this.blockchain.value === this.TICKET_PRICE, 'Must send 100 KLV');\n                this.buyTicket(nums, eb);\n            }\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Claim daily free tickets (based on staking)\n     */\n    claimFreeTickets() {\n        const caller = this.blockchain.caller;\n        \n        this.require(this.storage.roundActive, 'Round not active');\n        this.require(this.storage.kpepeStaking, 'Staking contract not set');\n        \n        // Check if new draw occurred\n        const currentDay = Math.floor(this.blockchain.timestamp / 86400);\n        const lastDrawDay = Math.floor(this.storage.lastDrawTime / 86400);\n        \n        if (currentDay > lastDrawDay) {\n            this.expireAllFreeTickets();\n        }\n        \n        // Track player\n        if (!this.isFreeTicketPlayer[caller]) {\n            this.isFreeTicketPlayer[caller] = true;\n            this.freeTicketPlayers.push(caller);\n        }\n        \n        this.freeTicketCredits[caller]++;\n        this.lastFreeTicketClaim[caller] = this.blockchain.timestamp;\n        \n        this.blockchain.emit('FreeTicketsClaimed', { player: caller, amount: 1 });\n    }\n    \n    /**\n     * Get free tickets available\n     */\n    getFreeTicketsAvailable() {\n        const caller = this.blockchain.caller;\n        \n        const currentDay = Math.floor(this.blockchain.timestamp / 86400);\n        const lastDrawDay = Math.floor(this.storage.lastDrawTime / 86400);\n        \n        if (currentDay > lastDrawDay) {\n            return 0;\n        }\n        \n        return this.freeTicketCredits[caller] || 0;\n    }\n    \n    /**\n     * Start the draw\n     */\n    startDraw() {\n        const caller = this.blockchain.caller;\n        \n        this.require(!this.storage.drawInProgress, 'Draw already in progress');\n        this.require(this.tickets.length > 0, 'No tickets to draw');\n        this.require(this.storage.roundActive, 'Round not active');\n        \n        this.storage.drawInProgress = true;\n        this.blockchain.emit('DrawStarted', this.blockchain.timestamp);\n    }\n    \n    /**\n     * Complete the draw - owner only\n     */\n    completeDraw() {\n        const cleanup = this.nonReentrant('completeDraw');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(this.blockchain.isOwner(caller), 'Not owner');\n            this.require(this.storage.drawInProgress, 'No draw in progress');\n            this.require(this.tickets.length > 0, 'No tickets');\n            \n            // Generate winning numbers using secure RNG\n            const { nums, eb } = this.generateSecureRandomNumbers();\n            this.storage.winningNumbers = nums;\n            this.storage.winningEightBall = eb;\n            \n            // Distribute prizes\n            const winners = this.distributePrizes();\n            \n            // Update pool\n            this.storage.prizePool = Math.floor(this.storage.prizePool * this.POOL_RETENTION / 10000);\n            \n            // Expire free tickets\n            this.expireAllFreeTickets();\n            \n            this.storage.drawInProgress = false;\n            this.storage.lastDrawTime = this.blockchain.timestamp;\n            \n            this.blockchain.emit('DrawCompleted', {\n                winningNumbers: this.storage.winningNumbers,\n                winningEightBall: this.storage.winningEightBall,\n                pool: this.storage.prizePool,\n                winners: winners\n            });\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Claim prize for a specific ticket\n     * @param {number} id - Ticket ID\n     */\n    claimPrize(id) {\n        const cleanup = this.nonReentrant('claimPrize');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(id < this.tickets.length, 'Invalid ticket');\n            \n            const ticket = this.tickets[id];\n            this.require(ticket.player === caller, 'Not your ticket');\n            this.require(ticket.hasWon, 'Ticket did not win');\n            this.require(!ticket.prizeClaimed, 'Prize already claimed');\n            \n            const tier = this.calculateTier(ticket);\n            const prize = this.calculatePrize(tier);\n            \n            this.require(prize > 0, 'No prize');\n            \n            ticket.prizeClaimed = true;\n            this.storage.prizePool -= prize;\n            \n            this.blockchain.transfer(caller, prize);\n            this.blockchain.emit('PrizeClaimed', { player: caller, amount: prize });\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Claim pending KPEPE prizes\n     */\n    claimKPEPEPrize() {\n        const cleanup = this.nonReentrant('claimKPEPEPrize');\n        try {\n            const caller = this.blockchain.caller;\n            \n            const pending = this.kpepePrizesPending[caller] || 0;\n            this.require(pending > 0, 'No pending KPEPE');\n            \n            this.kpepePrizesPending[caller] = 0;\n            \n            // Transfer KPEPE tokens\n            if (this.storage.kpepeToken) {\n                this.blockchain.callContract(\n                    this.storage.kpepeToken,\n                    'transfer',\n                    [caller, pending]\n                );\n            }\n            \n            this.blockchain.emit('KPEPEPrizeClaimed', { player: caller, amount: pending });\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Initialize wallets - called once\n     */\n    initializeWallets(projectWallet, prizePoolWallet) {\n        const caller = this.blockchain.caller;\n        \n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        this.require(!this.storage.projectWallet, 'Already initialized');\n        this.require(projectWallet && prizePoolWallet, 'Invalid wallets');\n        \n        this.storage.projectWallet = projectWallet;\n        this.storage.prizePoolWallet = prizePoolWallet;\n        \n        this.blockchain.emit('WalletsInitialized', { projectWallet, prizePoolWallet });\n    }\n    \n    /**\n     * Set KPEPE token address\n     */\n    setKPEPEToken(token) {\n        const caller = this.blockchain.caller;\n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        this.storage.kpepeToken = token;\n    }\n    \n    /**\n     * Set KPEPE staking contract\n     */\n    setKPEPEStaking(staking) {\n        const caller = this.blockchain.caller;\n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        this.storage.kpepeStaking = staking;\n    }\n    \n    /**\n     * Toggle round active/inactive\n     */\n    toggleRound() {\n        const caller = this.blockchain.caller;\n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        this.storage.roundActive = !this.storage.roundActive;\n    }\n    \n    /**\n     * Set KPEPE prize amounts\n     */\n    setKPEPEPrizes(j, m5, m48, m4, m38, m3, m28, m18, m8) {\n        const caller = this.blockchain.caller;\n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        \n        this.storage.kpepeJackpotPrize = j;\n        this.storage.kpepeMatch5Prize = m5;\n        this.storage.kpepeMatch48BPrize = m48;\n        this.storage.kpepeMatch4Prize = m4;\n        this.storage.kpepeMatch38BPrize = m38;\n        this.storage.kpepeMatch3Prize = m3;\n        this.storage.kpepeMatch28BPrize = m28;\n        this.storage.kpepeMatch18BPrize = m18;\n        this.storage.kpepeMatch8BOnlyPrize = m8;\n    }\n    \n    /**\n     * Withdraw from prize pool (max 10%)\n     */\n    withdrawPrizePool(amount) {\n        const cleanup = this.nonReentrant('withdrawPrizePool');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(this.blockchain.isOwner(caller), 'Not owner');\n            this.require(amount <= this.storage.prizePool, 'Insufficient balance');\n            this.require(amount <= this.storage.prizePool / 10, 'Max 10%');\n            this.require(this.storage.prizePoolWallet, 'Prize wallet not set');\n            \n            this.storage.prizePool -= amount;\n            this.blockchain.transfer(this.storage.prizePoolWallet, amount);\n            \n            this.blockchain.emit('PrizePoolWithdrawn', amount);\n        } finally {\n            cleanup();\n        }\n    }\n    \n    // ===== VIEW FUNCTIONS =====\n    \n    getPoolBalance() {\n        return this.storage.prizePool;\n    }\n    \n    getNextDrawTime() {\n        return Math.floor(this.storage.lastDrawTime / 86400 + 1) * 86400;\n    }\n    \n    getTicket(id) {\n        if (id >= this.tickets.length) return null;\n        return this.tickets[id];\n    }\n    \n    checkTicketResult(id) {\n        const ticket = this.getTicket(id);\n        if (!ticket) return { tier: 0, prize: 0 };\n        \n        const tier = this.calculateTier(ticket);\n        const prize = tier > 0 ? this.calculatePrize(tier) : 0;\n        \n        return { tier, prize };\n    }\n    \n    getPlayerTickets(address) {\n        return this.playerTicketIds[address] || [];\n    }\n    \n    // ===== INTERNAL HELPERS =#\n    \n    generateWinningNumbers() {\n        const { nums, eb } = this.generateSecureRandomNumbers();\n        this.storage.winningNumbers = nums;\n        this.storage.winningEightBall = eb;\n    }\n    \n    calculateTier(ticket) {\n        let matches = 0;\n        \n        for (let i = 0; i < this.MAIN_COUNT; i++) {\n            for (let j = 0; j < this.MAIN_COUNT; j++) {\n                if (ticket.mainNumbers[i] === this.storage.winningNumbers[j]) {\n                    matches++;\n                    break;\n                }\n            }\n        }\n        \n        const ebMatch = ticket.eightBall === this.storage.winningEightBall;\n        \n        if (matches === 5 && ebMatch) return 1;  // Jackpot\n        if (matches === 5) return 2;             // Match 5\n        if (matches === 4 && ebMatch) return 3;  // 4 + 8B\n        if (matches === 4) return 4;             // Match 4\n        if (matches === 3 && ebMatch) return 5;  // 3 + 8B\n        if (matches === 3) return 6;             // Match 3\n        if (matches === 2 && ebMatch) return 7;  // 2 + 8B\n        if (matches === 1 && ebMatch) return 8;  // 1 + 8B\n        if (ebMatch) return 9;                   // 8B only\n        \n        return 0;\n    }\n    \n    calculatePrize(tier) {\n        let pct = 0;\n        \n        switch (tier) {\n            case 1: pct = this.PRIZE_JACKPOT; break;\n            case 2: pct = this.PRIZE_MATCH5; break;\n            case 3: pct = this.PRIZE_4_8B; break;\n            case 4: pct = this.PRIZE_4; break;\n            case 5: pct = this.PRIZE_3_8B; break;\n            case 6: pct = this.PRIZE_3; break;\n            case 7: pct = this.PRIZE_2_8B; break;\n            case 8: pct = this.PRIZE_1_8B; break;\n            case 9: pct = this.PRIZE_8B_ONLY; break;\n            default: return 0;\n        }\n        \n        return Math.floor(this.storage.prizePool * pct / 10000);\n    }\n    \n    calculateKPEPE(tier) {\n        switch (tier) {\n            case 1: return this.storage.kpepeJackpotPrize;\n            case 2: return this.storage.kpepeMatch5Prize;\n            case 3: return this.storage.kpepeMatch48BPrize;\n            case 4: return this.storage.kpepeMatch4Prize;\n            case 5: return this.storage.kpepeMatch38BPrize;\n            case 6: return this.storage.kpepeMatch3Prize;\n            case 7: return this.storage.kpepeMatch28BPrize;\n            case 8: return this.storage.kpepeMatch18BPrize;\n            case 9: return this.storage.kpepeMatch8BOnlyPrize;\n            default: return 0;\n        }\n    }\n    \n    distributePrizes() {\n        let winners = 0;\n        \n        for (let i = 0; i < this.tickets.length; i++) {\n            const ticket = this.tickets[i];\n            if (ticket.prizeClaimed) continue;\n            \n            const tier = this.calculateTier(ticket);\n            if (tier > 0) {\n                const prize = this.calculatePrize(tier);\n                if (prize > 0 && prize <= this.storage.prizePool) {\n                    ticket.hasWon = true;\n                    ticket.prizeClaimed = true;\n                    this.storage.prizePool -= prize;\n                    winners++;\n                    \n                    this.blockchain.transfer(ticket.player, prize);\n                    \n                    // Calculate KPEPE prize\n                    const kp = this.calculateKPEPE(tier);\n                    if (kp > 0 && this.storage.kpepeToken) {\n                        this.kpepePrizesPending[ticket.player] = \n                            (this.kpepePrizesPending[ticket.player] || 0) + kp;\n                    }\n                    \n                    this.blockchain.emit('PrizeDistributed', {\n                        player: ticket.player,\n                        ticketId: i,\n                        tier,\n                        amount: prize\n                    });\n                }\n            }\n        }\n        \n        return winners;\n    }\n    \n    createFreeTicket(nums, eb) {\n        const caller = this.blockchain.caller;\n        \n        const ticket = {\n            player: caller,\n            mainNumbers: nums,\n            eightBall: eb,\n            purchaseTime: this.blockchain.timestamp,\n            hasWon: false,\n            prizeClaimed: false,\n            isFree: true\n        };\n        \n        const id = this.tickets.length;\n        this.tickets.push(ticket);\n        \n        if (!this.playerTicketIds[caller]) {\n            this.playerTicketIds[caller] = [];\n        }\n        this.playerTicketIds[caller].push(id);\n        \n        this.storage.totalTicketsSold++;\n        \n        this.blockchain.emit('TicketPurchased', { id, player: caller, nums, eb, isFree: true });\n    }\n    \n    expireAllFreeTickets() {\n        for (let i = 0; i < this.freeTicketPlayers.length; i++) {\n            const player = this.freeTicketPlayers[i];\n            this.freeTicketCredits[player] = 0;\n        }\n        this.freeTicketPlayers = [];\n    }\n    \n    /**\n     * Fallback - accept KLV deposits\n     */\n    deposit() {\n        // Contract can receive KLV\n    }\n}\n\n// Export for testing and deployment\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = KPEPEJackpot;\n}\n",
  "config": {
    "ticketPrice": 10000000000,
    "mainCount": 5,
    "eightRange": 20,
    "mainRange": 50,
    "prizes": {
      "jackpot": 4000,
      "match5": 1500,
      "match4_8b": 800,
      "match4": 500,
      "match3_8b": 600,
      "match3": 450,
      "match2_8b": 300,
      "match1_8b": 150,
      "match8b_only": 125
    },
    "poolRetention": 1975,
    "maxPool": 100000000000000
  }
}