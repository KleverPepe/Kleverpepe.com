{
  "contractCode": "/**\n * KPEPE Jackpot Lottery - JavaScript for KleverChain\n * Based on original Solidity contract\n * \n * DEPLOYMENT INSTRUCTIONS:\n * 1. Go to kleverscan.org/contracts\n * 2. Click \"Deploy Contract\"\n * 3. Upload this file as the contract code\n * 4. Set Gas Limit: 3,000,000\n * 5. Connect wallet and deploy\n */\n\n// Reentrancy Guard\nconst REENTRANCY_GUARD = {\n    locked: false,\n    \n    lock() {\n        if (this.locked) {\n            throw new Error('Reentrant call detected');\n        }\n        this.locked = true;\n    },\n    \n    unlock() {\n        this.locked = false;\n    }\n};\n\n// Cryptographically secure random number generator\nfunction secureRandom(seed) {\n    const x = Math.sin(seed++) * 10000;\n    return Math.floor((x - Math.floor(x)) * 1000000);\n}\n\n// Seed generator from multiple sources\nfunction generateSeed(blockchain) {\n    const sources = [\n        blockchain.timestamp,\n        blockchain.caller.charCodeAt(0),\n        Math.floor(Math.random() * 1000000),\n        Date.now(),\n        process.hrtime ? process.hrtime()[0] : 0\n    ];\n    \n    let seed = 0;\n    for (const s of sources) {\n        seed = ((seed << 5) - seed) + s;\n        seed = seed & seed; // Keep as integer\n    }\n    return Math.abs(seed);\n}\n\nclass KPEPEJackpot {\n    constructor(blockchain, initParams = {}) {\n        this.blockchain = blockchain;\n        \n        // Constants\n        this.TICKET_PRICE = 10000000000; // 100 KLV (8 decimals)\n        this.MAIN_COUNT = 5;\n        this.EIGHT_RANGE = 20;\n        this.MAIN_RANGE = 50;\n        \n        // Prize percentages (basis points)\n        this.PRIZE_JACKPOT = 4000;\n        this.PRIZE_MATCH5 = 1500;\n        this.PRIZE_4_8B = 800;\n        this.PRIZE_4 = 500;\n        this.PRIZE_3_8B = 600;\n        this.PRIZE_3 = 450;\n        this.PRIZE_2_8B = 300;\n        this.PRIZE_1_8B = 150;\n        this.PRIZE_8B_ONLY = 125;\n        this.POOL_RETENTION = 1975;\n        this.MAX_POOL = 100000000000000; // 1M KLV\n        \n        this.MIN_STAKE_FOR_FREE = 5000000000000; // 50K KPEPE\n        this.FREE_TICKETS_PER_DAY = 1;\n        \n        // Storage - Initialize with deployment params for one-transaction setup\n        this.storage = {\n            projectWallet: initParams.projectWallet || '',\n            prizePoolWallet: initParams.prizePoolWallet || '',\n            kpepeToken: initParams.kpepeToken || '',\n            kpepeStaking: initParams.kpepeStaking || '',\n            prizePool: 0,\n            totalTicketsSold: 0,\n            lastDrawTime: this.blockchain.timestamp || Date.now(),\n            drawInProgress: false,\n            roundActive: true,\n            winningNumbers: [0, 0, 0, 0, 0],\n            winningEightBall: 0,\n            kpepeJackpotPrize: initParams.kpepeJackpotPrize || 0,\n            kpepeMatch5Prize: initParams.kpepeMatch5Prize || 0,\n            kpepeMatch48BPrize: initParams.kpepeMatch48BPrize || 0,\n            kpepeMatch4Prize: initParams.kpepeMatch4Prize || 0,\n            kpepeMatch38BPrize: initParams.kpepeMatch38BPrize || 0,\n            kpepeMatch3Prize: initParams.kpepeMatch3Prize || 0,\n            kpepeMatch28BPrize: initParams.kpepeMatch28BPrize || 0,\n            kpepeMatch18BPrize: initParams.kpepeMatch18BPrize || 0,\n            kpepeMatch8BOnlyPrize: initParams.kpepeMatch8BOnlyPrize || 0,\n            // Commit-reveal scheme for tickets\n            ticketCommits: {}, // hash -> {nums, eb, revealTime, player}\n            revealDelay: 2, // blocks\n        };\n        \n        // State\n        this.tickets = [];\n        this.playerTicketIds = {};\n        this.kpepePrizesPending = {};\n        this.freeTicketCredits = {};\n        this.lastFreeTicketClaim = {};\n        this.freeTicketPlayers = [];\n        this.isFreeTicketPlayer = {};\n        \n        // Reentrancy guard for this contract\n        this._inFunction = {};\n    }\n    \n    require(condition, message) {\n        if (!condition) {\n            throw new Error(message || 'Requirement failed');\n        }\n    }\n    \n    // Reentrancy guard modifier\n    nonReentrant(functionName) {\n        if (this._inFunction[functionName]) {\n            throw new Error('Reentrant call not allowed');\n        }\n        this._inFunction[functionName] = true;\n        return () => { this._inFunction[functionName] = false; };\n    }\n    \n    init() {\n        // Only set defaults if not already set by constructor\n        if (!this.storage.lastDrawTime) {\n            this.storage.lastDrawTime = this.blockchain.timestamp;\n        }\n        if (this.storage.roundActive === undefined) {\n            this.storage.roundActive = true;\n        }\n        \n        // If caller is owner (deployment), auto-initialize\n        // This allows everything to be set in one transaction\n        try {\n            if (this.blockchain.isOwner && this.blockchain.isOwner(this.blockchain.caller)) {\n                // Contract is being deployed by owner - auto-configure\n                // All config was passed via constructor params\n            }\n        } catch (e) {\n            // ignore\n        }\n    }\n    \n    /**\n     * Deployment helper - returns initialization data\n     * Use this when deploying to get all params\n     */\n    static getDeployParams(config) {\n        return {\n            projectWallet: config.projectWallet || '',\n            prizePoolWallet: config.prizePoolWallet || '',\n            kpepeToken: config.kpepeToken || '',\n            kpepeStaking: config.kpepeStaking || '',\n            kpepeJackpotPrize: config.kpepeJackpotPrize || 0,\n            kpepeMatch5Prize: config.kpepeMatch5Prize || 0,\n            kpepeMatch48BPrize: config.kpepeMatch48BPrize || 0,\n            kpepeMatch4Prize: config.kpepeMatch4Prize || 0,\n            kpepeMatch38BPrize: config.kpepeMatch38BPrize || 0,\n            kpepeMatch3Prize: config.kpepeMatch3Prize || 0,\n            kpepeMatch28BPrize: config.kpepeMatch28BPrize || 0,\n            kpepeMatch18BPrize: config.kpepeMatch18BPrize || 0,\n            kpepeMatch8BOnlyPrize: config.kpepeMatch8BOnlyPrize || 0,\n        };\n    }\n    \n    /**\n     * Commit phase for ticket purchase (prevents frontrunning)\n     * @param {string} commitHash - Hash of (nums, eb, salt)\n     */\n    commitTicket(commitHash) {\n        const caller = this.blockchain.caller;\n        \n        this.require(this.storage.roundActive, 'Round not active');\n        this.require(!this.storage.ticketCommits[commitHash], 'Commit already exists');\n        \n        // Store commit without revealing numbers\n        this.storage.ticketCommits[commitHash] = {\n            player: caller,\n            commitTime: this.blockchain.timestamp,\n            revealed: false\n        };\n        \n        this.blockchain.emit('TicketCommitted', { player: caller, commitHash });\n    }\n    \n    /**\n     * Reveal phase for ticket purchase\n     * @param {number[]} nums - 5 main numbers (1-50)\n     * @param {number} eb - Eight ball number (1-20)\n     * @param {string} salt - Salt used in commit\n     */\n    revealTicket(nums, eb, salt) {\n        const caller = this.blockchain.caller;\n        \n        this.require(this.storage.roundActive, 'Round not active');\n        this.require(eb >= 1 && eb <= this.EIGHT_RANGE, 'Eight ball 1-20');\n        \n        // Validate numbers\n        for (let i = 0; i < this.MAIN_COUNT; i++) {\n            this.require(nums[i] >= 1 && nums[i] <= this.MAIN_RANGE, 'Numbers 1-50');\n            for (let j = i + 1; j < this.MAIN_COUNT; j++) {\n                this.require(nums[i] !== nums[j], 'Duplicate numbers');\n            }\n        }\n        \n        // Verify commit exists\n        const commitHash = this.hashCommit(nums, eb, salt);\n        const commit = this.storage.ticketCommits[commitHash];\n        this.require(commit, 'Commit not found');\n        this.require(commit.player === caller, 'Not your commit');\n        this.require(!commit.revealed, 'Already revealed');\n        \n        // Check delay (simulated - in real blockchain, check block number)\n        const timeSinceCommit = this.blockchain.timestamp - commit.commitTime;\n        this.require(timeSinceCommit >= this.storage.revealDelay * 15000, 'Reveal too soon'); // ~15s per block\n        \n        // Mark as revealed\n        commit.revealed = true;\n        commit.nums = nums;\n        commit.eb = eb;\n        \n        // Process payment (after commit-reveal)\n        let useFree = false;\n        if (this.freeTicketCredits[caller] > 0 && this.blockchain.value === 0) {\n            useFree = true;\n            this.freeTicketCredits[caller]--;\n        } else {\n            this.require(this.blockchain.value === this.TICKET_PRICE, 'Must send 100 KLV');\n        }\n        \n        let poolAmt = 0;\n        let projAmt = 0;\n        \n        if (!useFree) {\n            poolAmt = (this.TICKET_PRICE * 85) / 100;\n            projAmt = this.TICKET_PRICE - poolAmt;\n            \n            if (this.storage.prizePool + poolAmt > this.MAX_POOL) {\n                poolAmt = this.MAX_POOL - this.storage.prizePool;\n                projAmt = this.TICKET_PRICE - poolAmt;\n                this.blockchain.emit('PoolCapped', this.MAX_POOL);\n            }\n            \n            this.storage.prizePool += poolAmt;\n            \n            if (projAmt > 0 && this.storage.projectWallet) {\n                this.blockchain.transfer(this.storage.projectWallet, projAmt);\n            }\n        }\n        \n        // Create ticket\n        const ticket = {\n            player: caller,\n            mainNumbers: nums,\n            eightBall: eb,\n            purchaseTime: this.blockchain.timestamp,\n            hasWon: false,\n            prizeClaimed: false,\n            isFree: useFree,\n            commitHash: commitHash\n        };\n        \n        const id = this.tickets.length;\n        this.tickets.push(ticket);\n        \n        if (!this.playerTicketIds[caller]) {\n            this.playerTicketIds[caller] = [];\n        }\n        this.playerTicketIds[caller].push(id);\n        \n        this.storage.totalTicketsSold++;\n        \n        this.blockchain.emit('TicketRevealed', { id, player: caller, nums, eb, isFree: useFree });\n    }\n    \n    /**\n     * Generate commit hash from numbers, eb, and salt\n     */\n    hashCommit(nums, eb, salt) {\n        const data = JSON.stringify({ nums, eb, salt, player: this.blockchain.caller });\n        let hash = 0;\n        for (let i = 0; i < data.length; i++) {\n            const char = data.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash;\n        }\n        return '0x' + Math.abs(hash).toString(16).padStart(64, '0');\n    }\n    \n    /**\n     * Generate random numbers using secure RNG\n     */\n    generateSecureRandomNumbers() {\n        const seed = generateSeed(this.blockchain);\n        const nums = [];\n        const used = {};\n        \n        for (let i = 0; i < this.MAIN_COUNT; i++) {\n            let num;\n            do {\n                const rand = secureRandom(seed + i);\n                num = (rand % this.MAIN_RANGE) + 1;\n            } while (used[num]);\n            used[num] = true;\n            nums.push(num);\n        }\n        \n        nums.sort((a, b) => a - b);\n        \n        const eb = (secureRandom(seed + 100) % this.EIGHT_RANGE) + 1;\n        \n        return { nums, eb };\n    }\n    \n    /**\n     * Buy ticket with numbers (simplified - without commit-reveal for small purchases)\n     * @param {number[]} nums - 5 main numbers (1-50)\n     * @param {number} eb - Eight ball number (1-20)\n     */\n    buyTicket(nums, eb) {\n        const cleanup = this.nonReentrant('buyTicket');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(this.storage.roundActive, 'Round not active');\n            this.require(eb >= 1 && eb <= this.EIGHT_RANGE, 'Eight ball 1-20');\n            \n            // Validate numbers\n            for (let i = 0; i < this.MAIN_COUNT; i++) {\n                this.require(nums[i] >= 1 && nums[i] <= this.MAIN_RANGE, 'Numbers 1-50');\n                for (let j = i + 1; j < this.MAIN_COUNT; j++) {\n                    this.require(nums[i] !== nums[j], 'Duplicate numbers');\n                }\n            }\n            \n            let useFree = false;\n            \n            // Check free credits\n            if (this.freeTicketCredits[caller] > 0 && this.blockchain.value === 0) {\n                useFree = true;\n                this.freeTicketCredits[caller]--;\n            } else {\n                this.require(this.blockchain.value === this.TICKET_PRICE, 'Must send 100 KLV');\n            }\n            \n            let poolAmt = 0;\n            let projAmt = 0;\n            \n            if (!useFree) {\n                poolAmt = (this.TICKET_PRICE * 85) / 100;\n                projAmt = this.TICKET_PRICE - poolAmt;\n                \n                if (this.storage.prizePool + poolAmt > this.MAX_POOL) {\n                    poolAmt = this.MAX_POOL - this.storage.prizePool;\n                    projAmt = this.TICKET_PRICE - poolAmt;\n                    this.blockchain.emit('PoolCapped', this.MAX_POOL);\n                }\n                \n                this.storage.prizePool += poolAmt;\n                \n                if (projAmt > 0 && this.storage.projectWallet) {\n                    this.blockchain.transfer(this.storage.projectWallet, projAmt);\n                }\n            }\n            \n            // Create ticket\n            const ticket = {\n                player: caller,\n                mainNumbers: nums,\n                eightBall: eb,\n                purchaseTime: this.blockchain.timestamp,\n                hasWon: false,\n                prizeClaimed: false,\n                isFree: useFree\n            };\n            \n            const id = this.tickets.length;\n            this.tickets.push(ticket);\n            \n            if (!this.playerTicketIds[caller]) {\n                this.playerTicketIds[caller] = [];\n            }\n            this.playerTicketIds[caller].push(id);\n            \n            this.storage.totalTicketsSold++;\n            \n            this.blockchain.emit('TicketPurchased', { id, player: caller, nums, eb, isFree: useFree });\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Quick pick - uses secure random numbers\n     */\n    quickPick() {\n        const cleanup = this.nonReentrant('quickPick');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(this.storage.roundActive, 'Round not active');\n            \n            const { nums, eb } = this.generateSecureRandomNumbers();\n            \n            if (this.freeTicketCredits[caller] > 0 && this.blockchain.value === 0) {\n                this.freeTicketCredits[caller]--;\n                this.createFreeTicket(nums, eb);\n            } else {\n                this.require(this.blockchain.value === this.TICKET_PRICE, 'Must send 100 KLV');\n                this.buyTicket(nums, eb);\n            }\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Claim daily free tickets (based on staking)\n     */\n    claimFreeTickets() {\n        const caller = this.blockchain.caller;\n        \n        this.require(this.storage.roundActive, 'Round not active');\n        this.require(this.storage.kpepeStaking, 'Staking contract not set');\n        \n        // Check if new draw occurred\n        const currentDay = Math.floor(this.blockchain.timestamp / 86400);\n        const lastDrawDay = Math.floor(this.storage.lastDrawTime / 86400);\n        \n        if (currentDay > lastDrawDay) {\n            this.expireAllFreeTickets();\n        }\n        \n        // Track player\n        if (!this.isFreeTicketPlayer[caller]) {\n            this.isFreeTicketPlayer[caller] = true;\n            this.freeTicketPlayers.push(caller);\n        }\n        \n        this.freeTicketCredits[caller]++;\n        this.lastFreeTicketClaim[caller] = this.blockchain.timestamp;\n        \n        this.blockchain.emit('FreeTicketsClaimed', { player: caller, amount: 1 });\n    }\n    \n    /**\n     * Get free tickets available\n     */\n    getFreeTicketsAvailable() {\n        const caller = this.blockchain.caller;\n        \n        const currentDay = Math.floor(this.blockchain.timestamp / 86400);\n        const lastDrawDay = Math.floor(this.storage.lastDrawTime / 86400);\n        \n        if (currentDay > lastDrawDay) {\n            return 0;\n        }\n        \n        return this.freeTicketCredits[caller] || 0;\n    }\n    \n    /**\n     * Start the draw\n     */\n    startDraw() {\n        const caller = this.blockchain.caller;\n        \n        this.require(!this.storage.drawInProgress, 'Draw already in progress');\n        this.require(this.tickets.length > 0, 'No tickets to draw');\n        this.require(this.storage.roundActive, 'Round not active');\n        \n        this.storage.drawInProgress = true;\n        this.blockchain.emit('DrawStarted', this.blockchain.timestamp);\n    }\n    \n    /**\n     * Complete the draw - owner only\n     */\n    completeDraw() {\n        const cleanup = this.nonReentrant('completeDraw');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(this.blockchain.isOwner(caller), 'Not owner');\n            this.require(this.storage.drawInProgress, 'No draw in progress');\n            this.require(this.tickets.length > 0, 'No tickets');\n            \n            // Generate winning numbers using secure RNG\n            const { nums, eb } = this.generateSecureRandomNumbers();\n            this.storage.winningNumbers = nums;\n            this.storage.winningEightBall = eb;\n            \n            // Distribute prizes\n            const winners = this.distributePrizes();\n            \n            // Update pool\n            this.storage.prizePool = Math.floor(this.storage.prizePool * this.POOL_RETENTION / 10000);\n            \n            // Expire free tickets\n            this.expireAllFreeTickets();\n            \n            this.storage.drawInProgress = false;\n            this.storage.lastDrawTime = this.blockchain.timestamp;\n            \n            this.blockchain.emit('DrawCompleted', {\n                winningNumbers: this.storage.winningNumbers,\n                winningEightBall: this.storage.winningEightBall,\n                pool: this.storage.prizePool,\n                winners: winners\n            });\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Claim prize for a specific ticket\n     * @param {number} id - Ticket ID\n     */\n    claimPrize(id) {\n        const cleanup = this.nonReentrant('claimPrize');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(id < this.tickets.length, 'Invalid ticket');\n            \n            const ticket = this.tickets[id];\n            this.require(ticket.player === caller, 'Not your ticket');\n            this.require(ticket.hasWon, 'Ticket did not win');\n            this.require(!ticket.prizeClaimed, 'Prize already claimed');\n            \n            const tier = this.calculateTier(ticket);\n            const prize = this.calculatePrize(tier);\n            \n            this.require(prize > 0, 'No prize');\n            \n            ticket.prizeClaimed = true;\n            this.storage.prizePool -= prize;\n            \n            this.blockchain.transfer(caller, prize);\n            this.blockchain.emit('PrizeClaimed', { player: caller, amount: prize });\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Claim pending KPEPE prizes\n     */\n    claimKPEPEPrize() {\n        const cleanup = this.nonReentrant('claimKPEPEPrize');\n        try {\n            const caller = this.blockchain.caller;\n            \n            const pending = this.kpepePrizesPending[caller] || 0;\n            this.require(pending > 0, 'No pending KPEPE');\n            \n            this.kpepePrizesPending[caller] = 0;\n            \n            // Transfer KPEPE tokens\n            if (this.storage.kpepeToken) {\n                this.blockchain.callContract(\n                    this.storage.kpepeToken,\n                    'transfer',\n                    [caller, pending]\n                );\n            }\n            \n            this.blockchain.emit('KPEPEPrizeClaimed', { player: caller, amount: pending });\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * Initialize wallets - called once\n     */\n    initializeWallets(projectWallet, prizePoolWallet) {\n        const caller = this.blockchain.caller;\n        \n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        this.require(!this.storage.projectWallet, 'Already initialized');\n        this.require(projectWallet && prizePoolWallet, 'Invalid wallets');\n        \n        this.storage.projectWallet = projectWallet;\n        this.storage.prizePoolWallet = prizePoolWallet;\n        \n        this.blockchain.emit('WalletsInitialized', { projectWallet, prizePoolWallet });\n    }\n    \n    /**\n     * Set KPEPE token address\n     */\n    setKPEPEToken(token) {\n        const caller = this.blockchain.caller;\n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        this.storage.kpepeToken = token;\n    }\n    \n    /**\n     * Set KPEPE staking contract\n     */\n    setKPEPEStaking(staking) {\n        const caller = this.blockchain.caller;\n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        this.storage.kpepeStaking = staking;\n    }\n    \n    /**\n     * Toggle round active/inactive\n     */\n    toggleRound() {\n        const caller = this.blockchain.caller;\n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        this.storage.roundActive = !this.storage.roundActive;\n    }\n    \n    /**\n     * Set KPEPE prize amounts\n     */\n    setKPEPEPrizes(j, m5, m48, m4, m38, m3, m28, m18, m8) {\n        const caller = this.blockchain.caller;\n        this.require(this.blockchain.isOwner(caller), 'Not owner');\n        \n        this.storage.kpepeJackpotPrize = j;\n        this.storage.kpepeMatch5Prize = m5;\n        this.storage.kpepeMatch48BPrize = m48;\n        this.storage.kpepeMatch4Prize = m4;\n        this.storage.kpepeMatch38BPrize = m38;\n        this.storage.kpepeMatch3Prize = m3;\n        this.storage.kpepeMatch28BPrize = m28;\n        this.storage.kpepeMatch18BPrize = m18;\n        this.storage.kpepeMatch8BOnlyPrize = m8;\n    }\n    \n    /**\n     * Withdraw from prize pool (max 10%)\n     */\n    withdrawPrizePool(amount) {\n        const cleanup = this.nonReentrant('withdrawPrizePool');\n        try {\n            const caller = this.blockchain.caller;\n            \n            this.require(this.blockchain.isOwner(caller), 'Not owner');\n            this.require(amount <= this.storage.prizePool, 'Insufficient balance');\n            this.require(amount <= this.storage.prizePool / 10, 'Max 10%');\n            this.require(this.storage.prizePoolWallet, 'Prize wallet not set');\n            \n            this.storage.prizePool -= amount;\n            this.blockchain.transfer(this.storage.prizePoolWallet, amount);\n            \n            this.blockchain.emit('PrizePoolWithdrawn', amount);\n        } finally {\n            cleanup();\n        }\n    }\n    \n    // ===== VIEW FUNCTIONS =====\n    \n    getPoolBalance() {\n        return this.storage.prizePool;\n    }\n    \n    getNextDrawTime() {\n        return Math.floor(this.storage.lastDrawTime / 86400 + 1) * 86400;\n    }\n    \n    getTicket(id) {\n        if (id >= this.tickets.length) return null;\n        return this.tickets[id];\n    }\n    \n    checkTicketResult(id) {\n        const ticket = this.getTicket(id);\n        if (!ticket) return { tier: 0, prize: 0 };\n        \n        const tier = this.calculateTier(ticket);\n        const prize = tier > 0 ? this.calculatePrize(tier) : 0;\n        \n        return { tier, prize };\n    }\n    \n    getPlayerTickets(address) {\n        return this.playerTicketIds[address] || [];\n    }\n    \n    // ===== INTERNAL HELPERS =#\n    \n    generateWinningNumbers() {\n        const { nums, eb } = this.generateSecureRandomNumbers();\n        this.storage.winningNumbers = nums;\n        this.storage.winningEightBall = eb;\n    }\n    \n    calculateTier(ticket) {\n        let matches = 0;\n        \n        for (let i = 0; i < this.MAIN_COUNT; i++) {\n            for (let j = 0; j < this.MAIN_COUNT; j++) {\n                if (ticket.mainNumbers[i] === this.storage.winningNumbers[j]) {\n                    matches++;\n                    break;\n                }\n            }\n        }\n        \n        const ebMatch = ticket.eightBall === this.storage.winningEightBall;\n        \n        if (matches === 5 && ebMatch) return 1;  // Jackpot\n        if (matches === 5) return 2;             // Match 5\n        if (matches === 4 && ebMatch) return 3;  // 4 + 8B\n        if (matches === 4) return 4;             // Match 4\n        if (matches === 3 && ebMatch) return 5;  // 3 + 8B\n        if (matches === 3) return 6;             // Match 3\n        if (matches === 2 && ebMatch) return 7;  // 2 + 8B\n        if (matches === 1 && ebMatch) return 8;  // 1 + 8B\n        if (ebMatch) return 9;                   // 8B only\n        \n        return 0;\n    }\n    \n    calculatePrize(tier) {\n        let pct = 0;\n        \n        switch (tier) {\n            case 1: pct = this.PRIZE_JACKPOT; break;\n            case 2: pct = this.PRIZE_MATCH5; break;\n            case 3: pct = this.PRIZE_4_8B; break;\n            case 4: pct = this.PRIZE_4; break;\n            case 5: pct = this.PRIZE_3_8B; break;\n            case 6: pct = this.PRIZE_3; break;\n            case 7: pct = this.PRIZE_2_8B; break;\n            case 8: pct = this.PRIZE_1_8B; break;\n            case 9: pct = this.PRIZE_8B_ONLY; break;\n            default: return 0;\n        }\n        \n        return Math.floor(this.storage.prizePool * pct / 10000);\n    }\n    \n    calculateKPEPE(tier) {\n        switch (tier) {\n            case 1: return this.storage.kpepeJackpotPrize;\n            case 2: return this.storage.kpepeMatch5Prize;\n            case 3: return this.storage.kpepeMatch48BPrize;\n            case 4: return this.storage.kpepeMatch4Prize;\n            case 5: return this.storage.kpepeMatch38BPrize;\n            case 6: return this.storage.kpepeMatch3Prize;\n            case 7: return this.storage.kpepeMatch28BPrize;\n            case 8: return this.storage.kpepeMatch18BPrize;\n            case 9: return this.storage.kpepeMatch8BOnlyPrize;\n            default: return 0;\n        }\n    }\n    \n    distributePrizes() {\n        let winners = 0;\n        \n        for (let i = 0; i < this.tickets.length; i++) {\n            const ticket = this.tickets[i];\n            if (ticket.prizeClaimed) continue;\n            \n            const tier = this.calculateTier(ticket);\n            if (tier > 0) {\n                const prize = this.calculatePrize(tier);\n                if (prize > 0 && prize <= this.storage.prizePool) {\n                    ticket.hasWon = true;\n                    ticket.prizeClaimed = true;\n                    this.storage.prizePool -= prize;\n                    winners++;\n                    \n                    this.blockchain.transfer(ticket.player, prize);\n                    \n                    // Calculate KPEPE prize\n                    const kp = this.calculateKPEPE(tier);\n                    if (kp > 0 && this.storage.kpepeToken) {\n                        this.kpepePrizesPending[ticket.player] = \n                            (this.kpepePrizesPending[ticket.player] || 0) + kp;\n                    }\n                    \n                    this.blockchain.emit('PrizeDistributed', {\n                        player: ticket.player,\n                        ticketId: i,\n                        tier,\n                        amount: prize\n                    });\n                }\n            }\n        }\n        \n        return winners;\n    }\n    \n    createFreeTicket(nums, eb) {\n        const caller = this.blockchain.caller;\n        \n        const ticket = {\n            player: caller,\n            mainNumbers: nums,\n            eightBall: eb,\n            purchaseTime: this.blockchain.timestamp,\n            hasWon: false,\n            prizeClaimed: false,\n            isFree: true\n        };\n        \n        const id = this.tickets.length;\n        this.tickets.push(ticket);\n        \n        if (!this.playerTicketIds[caller]) {\n            this.playerTicketIds[caller] = [];\n        }\n        this.playerTicketIds[caller].push(id);\n        \n        this.storage.totalTicketsSold++;\n        \n        this.blockchain.emit('TicketPurchased', { id, player: caller, nums, eb, isFree: true });\n    }\n    \n    expireAllFreeTickets() {\n        for (let i = 0; i < this.freeTicketPlayers.length; i++) {\n            const player = this.freeTicketPlayers[i];\n            this.freeTicketCredits[player] = 0;\n        }\n        this.freeTicketPlayers = [];\n    }\n    \n    /**\n     * Fallback - accept KLV deposits\n     */\n    deposit() {\n        // Contract can receive KLV\n    }\n}\n\n// Export for testing and deployment\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = KPEPEJackpot;\n}\n",
  "deployTx": {
    "type": "deploy",
    "code": "LyoqCiAqIEtQRVBFIEphY2twb3QgTG90dGVyeSAtIEphdmFTY3JpcHQgZm9yIEtsZXZlckNoYWluCiAqIEJhc2VkIG9uIG9yaWdpbmFsIFNvbGlkaXR5IGNvbnRyYWN0CiAqIAogKiBERVBMT1lNRU5UIElOU1RSVUNUSU9OUzoKICogMS4gR28gdG8ga2xldmVyc2Nhbi5vcmcvY29udHJhY3RzCiAqIDIuIENsaWNrICJEZXBsb3kgQ29udHJhY3QiCiAqIDMuIFVwbG9hZCB0aGlzIGZpbGUgYXMgdGhlIGNvbnRyYWN0IGNvZGUKICogNC4gU2V0IEdhcyBMaW1pdDogMywwMDAsMDAwCiAqIDUuIENvbm5lY3Qgd2FsbGV0IGFuZCBkZXBsb3kKICovCgovLyBSZWVudHJhbmN5IEd1YXJkCmNvbnN0IFJFRU5UUkFOQ1lfR1VBUkQgPSB7CiAgICBsb2NrZWQ6IGZhbHNlLAogICAgCiAgICBsb2NrKCkgewogICAgICAgIGlmICh0aGlzLmxvY2tlZCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZW50cmFudCBjYWxsIGRldGVjdGVkJyk7CiAgICAgICAgfQogICAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTsKICAgIH0sCiAgICAKICAgIHVubG9jaygpIHsKICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlOwogICAgfQp9OwoKLy8gQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yCmZ1bmN0aW9uIHNlY3VyZVJhbmRvbShzZWVkKSB7CiAgICBjb25zdCB4ID0gTWF0aC5zaW4oc2VlZCsrKSAqIDEwMDAwOwogICAgcmV0dXJuIE1hdGguZmxvb3IoKHggLSBNYXRoLmZsb29yKHgpKSAqIDEwMDAwMDApOwp9CgovLyBTZWVkIGdlbmVyYXRvciBmcm9tIG11bHRpcGxlIHNvdXJjZXMKZnVuY3Rpb24gZ2VuZXJhdGVTZWVkKGJsb2NrY2hhaW4pIHsKICAgIGNvbnN0IHNvdXJjZXMgPSBbCiAgICAgICAgYmxvY2tjaGFpbi50aW1lc3RhbXAsCiAgICAgICAgYmxvY2tjaGFpbi5jYWxsZXIuY2hhckNvZGVBdCgwKSwKICAgICAgICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKSwKICAgICAgICBEYXRlLm5vdygpLAogICAgICAgIHByb2Nlc3MuaHJ0aW1lID8gcHJvY2Vzcy5ocnRpbWUoKVswXSA6IDAKICAgIF07CiAgICAKICAgIGxldCBzZWVkID0gMDsKICAgIGZvciAoY29uc3QgcyBvZiBzb3VyY2VzKSB7CiAgICAgICAgc2VlZCA9ICgoc2VlZCA8PCA1KSAtIHNlZWQpICsgczsKICAgICAgICBzZWVkID0gc2VlZCAmIHNlZWQ7IC8vIEtlZXAgYXMgaW50ZWdlcgogICAgfQogICAgcmV0dXJuIE1hdGguYWJzKHNlZWQpOwp9CgpjbGFzcyBLUEVQRUphY2twb3QgewogICAgY29uc3RydWN0b3IoYmxvY2tjaGFpbiwgaW5pdFBhcmFtcyA9IHt9KSB7CiAgICAgICAgdGhpcy5ibG9ja2NoYWluID0gYmxvY2tjaGFpbjsKICAgICAgICAKICAgICAgICAvLyBDb25zdGFudHMKICAgICAgICB0aGlzLlRJQ0tFVF9QUklDRSA9IDEwMDAwMDAwMDAwOyAvLyAxMDAgS0xWICg4IGRlY2ltYWxzKQogICAgICAgIHRoaXMuTUFJTl9DT1VOVCA9IDU7CiAgICAgICAgdGhpcy5FSUdIVF9SQU5HRSA9IDIwOwogICAgICAgIHRoaXMuTUFJTl9SQU5HRSA9IDUwOwogICAgICAgIAogICAgICAgIC8vIFByaXplIHBlcmNlbnRhZ2VzIChiYXNpcyBwb2ludHMpCiAgICAgICAgdGhpcy5QUklaRV9KQUNLUE9UID0gNDAwMDsKICAgICAgICB0aGlzLlBSSVpFX01BVENINSA9IDE1MDA7CiAgICAgICAgdGhpcy5QUklaRV80XzhCID0gODAwOwogICAgICAgIHRoaXMuUFJJWkVfNCA9IDUwMDsKICAgICAgICB0aGlzLlBSSVpFXzNfOEIgPSA2MDA7CiAgICAgICAgdGhpcy5QUklaRV8zID0gNDUwOwogICAgICAgIHRoaXMuUFJJWkVfMl84QiA9IDMwMDsKICAgICAgICB0aGlzLlBSSVpFXzFfOEIgPSAxNTA7CiAgICAgICAgdGhpcy5QUklaRV84Ql9PTkxZID0gMTI1OwogICAgICAgIHRoaXMuUE9PTF9SRVRFTlRJT04gPSAxOTc1OwogICAgICAgIHRoaXMuTUFYX1BPT0wgPSAxMDAwMDAwMDAwMDAwMDA7IC8vIDFNIEtMVgogICAgICAgIAogICAgICAgIHRoaXMuTUlOX1NUQUtFX0ZPUl9GUkVFID0gNTAwMDAwMDAwMDAwMDsgLy8gNTBLIEtQRVBFCiAgICAgICAgdGhpcy5GUkVFX1RJQ0tFVFNfUEVSX0RBWSA9IDE7CiAgICAgICAgCiAgICAgICAgLy8gU3RvcmFnZSAtIEluaXRpYWxpemUgd2l0aCBkZXBsb3ltZW50IHBhcmFtcyBmb3Igb25lLXRyYW5zYWN0aW9uIHNldHVwCiAgICAgICAgdGhpcy5zdG9yYWdlID0gewogICAgICAgICAgICBwcm9qZWN0V2FsbGV0OiBpbml0UGFyYW1zLnByb2plY3RXYWxsZXQgfHwgJycsCiAgICAgICAgICAgIHByaXplUG9vbFdhbGxldDogaW5pdFBhcmFtcy5wcml6ZVBvb2xXYWxsZXQgfHwgJycsCiAgICAgICAgICAgIGtwZXBlVG9rZW46IGluaXRQYXJhbXMua3BlcGVUb2tlbiB8fCAnJywKICAgICAgICAgICAga3BlcGVTdGFraW5nOiBpbml0UGFyYW1zLmtwZXBlU3Rha2luZyB8fCAnJywKICAgICAgICAgICAgcHJpemVQb29sOiAwLAogICAgICAgICAgICB0b3RhbFRpY2tldHNTb2xkOiAwLAogICAgICAgICAgICBsYXN0RHJhd1RpbWU6IHRoaXMuYmxvY2tjaGFpbi50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSwKICAgICAgICAgICAgZHJhd0luUHJvZ3Jlc3M6IGZhbHNlLAogICAgICAgICAgICByb3VuZEFjdGl2ZTogdHJ1ZSwKICAgICAgICAgICAgd2lubmluZ051bWJlcnM6IFswLCAwLCAwLCAwLCAwXSwKICAgICAgICAgICAgd2lubmluZ0VpZ2h0QmFsbDogMCwKICAgICAgICAgICAga3BlcGVKYWNrcG90UHJpemU6IGluaXRQYXJhbXMua3BlcGVKYWNrcG90UHJpemUgfHwgMCwKICAgICAgICAgICAga3BlcGVNYXRjaDVQcml6ZTogaW5pdFBhcmFtcy5rcGVwZU1hdGNoNVByaXplIHx8IDAsCiAgICAgICAgICAgIGtwZXBlTWF0Y2g0OEJQcml6ZTogaW5pdFBhcmFtcy5rcGVwZU1hdGNoNDhCUHJpemUgfHwgMCwKICAgICAgICAgICAga3BlcGVNYXRjaDRQcml6ZTogaW5pdFBhcmFtcy5rcGVwZU1hdGNoNFByaXplIHx8IDAsCiAgICAgICAgICAgIGtwZXBlTWF0Y2gzOEJQcml6ZTogaW5pdFBhcmFtcy5rcGVwZU1hdGNoMzhCUHJpemUgfHwgMCwKICAgICAgICAgICAga3BlcGVNYXRjaDNQcml6ZTogaW5pdFBhcmFtcy5rcGVwZU1hdGNoM1ByaXplIHx8IDAsCiAgICAgICAgICAgIGtwZXBlTWF0Y2gyOEJQcml6ZTogaW5pdFBhcmFtcy5rcGVwZU1hdGNoMjhCUHJpemUgfHwgMCwKICAgICAgICAgICAga3BlcGVNYXRjaDE4QlByaXplOiBpbml0UGFyYW1zLmtwZXBlTWF0Y2gxOEJQcml6ZSB8fCAwLAogICAgICAgICAgICBrcGVwZU1hdGNoOEJPbmx5UHJpemU6IGluaXRQYXJhbXMua3BlcGVNYXRjaDhCT25seVByaXplIHx8IDAsCiAgICAgICAgICAgIC8vIENvbW1pdC1yZXZlYWwgc2NoZW1lIGZvciB0aWNrZXRzCiAgICAgICAgICAgIHRpY2tldENvbW1pdHM6IHt9LCAvLyBoYXNoIC0+IHtudW1zLCBlYiwgcmV2ZWFsVGltZSwgcGxheWVyfQogICAgICAgICAgICByZXZlYWxEZWxheTogMiwgLy8gYmxvY2tzCiAgICAgICAgfTsKICAgICAgICAKICAgICAgICAvLyBTdGF0ZQogICAgICAgIHRoaXMudGlja2V0cyA9IFtdOwogICAgICAgIHRoaXMucGxheWVyVGlja2V0SWRzID0ge307CiAgICAgICAgdGhpcy5rcGVwZVByaXplc1BlbmRpbmcgPSB7fTsKICAgICAgICB0aGlzLmZyZWVUaWNrZXRDcmVkaXRzID0ge307CiAgICAgICAgdGhpcy5sYXN0RnJlZVRpY2tldENsYWltID0ge307CiAgICAgICAgdGhpcy5mcmVlVGlja2V0UGxheWVycyA9IFtdOwogICAgICAgIHRoaXMuaXNGcmVlVGlja2V0UGxheWVyID0ge307CiAgICAgICAgCiAgICAgICAgLy8gUmVlbnRyYW5jeSBndWFyZCBmb3IgdGhpcyBjb250cmFjdAogICAgICAgIHRoaXMuX2luRnVuY3Rpb24gPSB7fTsKICAgIH0KICAgIAogICAgcmVxdWlyZShjb25kaXRpb24sIG1lc3NhZ2UpIHsKICAgICAgICBpZiAoIWNvbmRpdGlvbikgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnUmVxdWlyZW1lbnQgZmFpbGVkJyk7CiAgICAgICAgfQogICAgfQogICAgCiAgICAvLyBSZWVudHJhbmN5IGd1YXJkIG1vZGlmaWVyCiAgICBub25SZWVudHJhbnQoZnVuY3Rpb25OYW1lKSB7CiAgICAgICAgaWYgKHRoaXMuX2luRnVuY3Rpb25bZnVuY3Rpb25OYW1lXSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZW50cmFudCBjYWxsIG5vdCBhbGxvd2VkJyk7CiAgICAgICAgfQogICAgICAgIHRoaXMuX2luRnVuY3Rpb25bZnVuY3Rpb25OYW1lXSA9IHRydWU7CiAgICAgICAgcmV0dXJuICgpID0+IHsgdGhpcy5faW5GdW5jdGlvbltmdW5jdGlvbk5hbWVdID0gZmFsc2U7IH07CiAgICB9CiAgICAKICAgIGluaXQoKSB7CiAgICAgICAgLy8gT25seSBzZXQgZGVmYXVsdHMgaWYgbm90IGFscmVhZHkgc2V0IGJ5IGNvbnN0cnVjdG9yCiAgICAgICAgaWYgKCF0aGlzLnN0b3JhZ2UubGFzdERyYXdUaW1lKSB7CiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5sYXN0RHJhd1RpbWUgPSB0aGlzLmJsb2NrY2hhaW4udGltZXN0YW1wOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5zdG9yYWdlLnJvdW5kQWN0aXZlID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnJvdW5kQWN0aXZlID0gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8gSWYgY2FsbGVyIGlzIG93bmVyIChkZXBsb3ltZW50KSwgYXV0by1pbml0aWFsaXplCiAgICAgICAgLy8gVGhpcyBhbGxvd3MgZXZlcnl0aGluZyB0byBiZSBzZXQgaW4gb25lIHRyYW5zYWN0aW9uCiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tjaGFpbi5pc093bmVyICYmIHRoaXMuYmxvY2tjaGFpbi5pc093bmVyKHRoaXMuYmxvY2tjaGFpbi5jYWxsZXIpKSB7CiAgICAgICAgICAgICAgICAvLyBDb250cmFjdCBpcyBiZWluZyBkZXBsb3llZCBieSBvd25lciAtIGF1dG8tY29uZmlndXJlCiAgICAgICAgICAgICAgICAvLyBBbGwgY29uZmlnIHdhcyBwYXNzZWQgdmlhIGNvbnN0cnVjdG9yIHBhcmFtcwogICAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAvLyBpZ25vcmUKICAgICAgICB9CiAgICB9CiAgICAKICAgIC8qKgogICAgICogRGVwbG95bWVudCBoZWxwZXIgLSByZXR1cm5zIGluaXRpYWxpemF0aW9uIGRhdGEKICAgICAqIFVzZSB0aGlzIHdoZW4gZGVwbG95aW5nIHRvIGdldCBhbGwgcGFyYW1zCiAgICAgKi8KICAgIHN0YXRpYyBnZXREZXBsb3lQYXJhbXMoY29uZmlnKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgcHJvamVjdFdhbGxldDogY29uZmlnLnByb2plY3RXYWxsZXQgfHwgJycsCiAgICAgICAgICAgIHByaXplUG9vbFdhbGxldDogY29uZmlnLnByaXplUG9vbFdhbGxldCB8fCAnJywKICAgICAgICAgICAga3BlcGVUb2tlbjogY29uZmlnLmtwZXBlVG9rZW4gfHwgJycsCiAgICAgICAgICAgIGtwZXBlU3Rha2luZzogY29uZmlnLmtwZXBlU3Rha2luZyB8fCAnJywKICAgICAgICAgICAga3BlcGVKYWNrcG90UHJpemU6IGNvbmZpZy5rcGVwZUphY2twb3RQcml6ZSB8fCAwLAogICAgICAgICAgICBrcGVwZU1hdGNoNVByaXplOiBjb25maWcua3BlcGVNYXRjaDVQcml6ZSB8fCAwLAogICAgICAgICAgICBrcGVwZU1hdGNoNDhCUHJpemU6IGNvbmZpZy5rcGVwZU1hdGNoNDhCUHJpemUgfHwgMCwKICAgICAgICAgICAga3BlcGVNYXRjaDRQcml6ZTogY29uZmlnLmtwZXBlTWF0Y2g0UHJpemUgfHwgMCwKICAgICAgICAgICAga3BlcGVNYXRjaDM4QlByaXplOiBjb25maWcua3BlcGVNYXRjaDM4QlByaXplIHx8IDAsCiAgICAgICAgICAgIGtwZXBlTWF0Y2gzUHJpemU6IGNvbmZpZy5rcGVwZU1hdGNoM1ByaXplIHx8IDAsCiAgICAgICAgICAgIGtwZXBlTWF0Y2gyOEJQcml6ZTogY29uZmlnLmtwZXBlTWF0Y2gyOEJQcml6ZSB8fCAwLAogICAgICAgICAgICBrcGVwZU1hdGNoMThCUHJpemU6IGNvbmZpZy5rcGVwZU1hdGNoMThCUHJpemUgfHwgMCwKICAgICAgICAgICAga3BlcGVNYXRjaDhCT25seVByaXplOiBjb25maWcua3BlcGVNYXRjaDhCT25seVByaXplIHx8IDAsCiAgICAgICAgfTsKICAgIH0KICAgIAogICAgLyoqCiAgICAgKiBDb21taXQgcGhhc2UgZm9yIHRpY2tldCBwdXJjaGFzZSAocHJldmVudHMgZnJvbnRydW5uaW5nKQogICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbW1pdEhhc2ggLSBIYXNoIG9mIChudW1zLCBlYiwgc2FsdCkKICAgICAqLwogICAgY29tbWl0VGlja2V0KGNvbW1pdEhhc2gpIHsKICAgICAgICBjb25zdCBjYWxsZXIgPSB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyOwogICAgICAgIAogICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLnN0b3JhZ2Uucm91bmRBY3RpdmUsICdSb3VuZCBub3QgYWN0aXZlJyk7CiAgICAgICAgdGhpcy5yZXF1aXJlKCF0aGlzLnN0b3JhZ2UudGlja2V0Q29tbWl0c1tjb21taXRIYXNoXSwgJ0NvbW1pdCBhbHJlYWR5IGV4aXN0cycpOwogICAgICAgIAogICAgICAgIC8vIFN0b3JlIGNvbW1pdCB3aXRob3V0IHJldmVhbGluZyBudW1iZXJzCiAgICAgICAgdGhpcy5zdG9yYWdlLnRpY2tldENvbW1pdHNbY29tbWl0SGFzaF0gPSB7CiAgICAgICAgICAgIHBsYXllcjogY2FsbGVyLAogICAgICAgICAgICBjb21taXRUaW1lOiB0aGlzLmJsb2NrY2hhaW4udGltZXN0YW1wLAogICAgICAgICAgICByZXZlYWxlZDogZmFsc2UKICAgICAgICB9OwogICAgICAgIAogICAgICAgIHRoaXMuYmxvY2tjaGFpbi5lbWl0KCdUaWNrZXRDb21taXR0ZWQnLCB7IHBsYXllcjogY2FsbGVyLCBjb21taXRIYXNoIH0pOwogICAgfQogICAgCiAgICAvKioKICAgICAqIFJldmVhbCBwaGFzZSBmb3IgdGlja2V0IHB1cmNoYXNlCiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBudW1zIC0gNSBtYWluIG51bWJlcnMgKDEtNTApCiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWIgLSBFaWdodCBiYWxsIG51bWJlciAoMS0yMCkKICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzYWx0IC0gU2FsdCB1c2VkIGluIGNvbW1pdAogICAgICovCiAgICByZXZlYWxUaWNrZXQobnVtcywgZWIsIHNhbHQpIHsKICAgICAgICBjb25zdCBjYWxsZXIgPSB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyOwogICAgICAgIAogICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLnN0b3JhZ2Uucm91bmRBY3RpdmUsICdSb3VuZCBub3QgYWN0aXZlJyk7CiAgICAgICAgdGhpcy5yZXF1aXJlKGViID49IDEgJiYgZWIgPD0gdGhpcy5FSUdIVF9SQU5HRSwgJ0VpZ2h0IGJhbGwgMS0yMCcpOwogICAgICAgIAogICAgICAgIC8vIFZhbGlkYXRlIG51bWJlcnMKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuTUFJTl9DT1VOVDsgaSsrKSB7CiAgICAgICAgICAgIHRoaXMucmVxdWlyZShudW1zW2ldID49IDEgJiYgbnVtc1tpXSA8PSB0aGlzLk1BSU5fUkFOR0UsICdOdW1iZXJzIDEtNTAnKTsKICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgdGhpcy5NQUlOX0NPVU5UOyBqKyspIHsKICAgICAgICAgICAgICAgIHRoaXMucmVxdWlyZShudW1zW2ldICE9PSBudW1zW2pdLCAnRHVwbGljYXRlIG51bWJlcnMnKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAKICAgICAgICAvLyBWZXJpZnkgY29tbWl0IGV4aXN0cwogICAgICAgIGNvbnN0IGNvbW1pdEhhc2ggPSB0aGlzLmhhc2hDb21taXQobnVtcywgZWIsIHNhbHQpOwogICAgICAgIGNvbnN0IGNvbW1pdCA9IHRoaXMuc3RvcmFnZS50aWNrZXRDb21taXRzW2NvbW1pdEhhc2hdOwogICAgICAgIHRoaXMucmVxdWlyZShjb21taXQsICdDb21taXQgbm90IGZvdW5kJyk7CiAgICAgICAgdGhpcy5yZXF1aXJlKGNvbW1pdC5wbGF5ZXIgPT09IGNhbGxlciwgJ05vdCB5b3VyIGNvbW1pdCcpOwogICAgICAgIHRoaXMucmVxdWlyZSghY29tbWl0LnJldmVhbGVkLCAnQWxyZWFkeSByZXZlYWxlZCcpOwogICAgICAgIAogICAgICAgIC8vIENoZWNrIGRlbGF5IChzaW11bGF0ZWQgLSBpbiByZWFsIGJsb2NrY2hhaW4sIGNoZWNrIGJsb2NrIG51bWJlcikKICAgICAgICBjb25zdCB0aW1lU2luY2VDb21taXQgPSB0aGlzLmJsb2NrY2hhaW4udGltZXN0YW1wIC0gY29tbWl0LmNvbW1pdFRpbWU7CiAgICAgICAgdGhpcy5yZXF1aXJlKHRpbWVTaW5jZUNvbW1pdCA+PSB0aGlzLnN0b3JhZ2UucmV2ZWFsRGVsYXkgKiAxNTAwMCwgJ1JldmVhbCB0b28gc29vbicpOyAvLyB+MTVzIHBlciBibG9jawogICAgICAgIAogICAgICAgIC8vIE1hcmsgYXMgcmV2ZWFsZWQKICAgICAgICBjb21taXQucmV2ZWFsZWQgPSB0cnVlOwogICAgICAgIGNvbW1pdC5udW1zID0gbnVtczsKICAgICAgICBjb21taXQuZWIgPSBlYjsKICAgICAgICAKICAgICAgICAvLyBQcm9jZXNzIHBheW1lbnQgKGFmdGVyIGNvbW1pdC1yZXZlYWwpCiAgICAgICAgbGV0IHVzZUZyZWUgPSBmYWxzZTsKICAgICAgICBpZiAodGhpcy5mcmVlVGlja2V0Q3JlZGl0c1tjYWxsZXJdID4gMCAmJiB0aGlzLmJsb2NrY2hhaW4udmFsdWUgPT09IDApIHsKICAgICAgICAgICAgdXNlRnJlZSA9IHRydWU7CiAgICAgICAgICAgIHRoaXMuZnJlZVRpY2tldENyZWRpdHNbY2FsbGVyXS0tOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLmJsb2NrY2hhaW4udmFsdWUgPT09IHRoaXMuVElDS0VUX1BSSUNFLCAnTXVzdCBzZW5kIDEwMCBLTFYnKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgbGV0IHBvb2xBbXQgPSAwOwogICAgICAgIGxldCBwcm9qQW10ID0gMDsKICAgICAgICAKICAgICAgICBpZiAoIXVzZUZyZWUpIHsKICAgICAgICAgICAgcG9vbEFtdCA9ICh0aGlzLlRJQ0tFVF9QUklDRSAqIDg1KSAvIDEwMDsKICAgICAgICAgICAgcHJvakFtdCA9IHRoaXMuVElDS0VUX1BSSUNFIC0gcG9vbEFtdDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2UucHJpemVQb29sICsgcG9vbEFtdCA+IHRoaXMuTUFYX1BPT0wpIHsKICAgICAgICAgICAgICAgIHBvb2xBbXQgPSB0aGlzLk1BWF9QT09MIC0gdGhpcy5zdG9yYWdlLnByaXplUG9vbDsKICAgICAgICAgICAgICAgIHByb2pBbXQgPSB0aGlzLlRJQ0tFVF9QUklDRSAtIHBvb2xBbXQ7CiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrY2hhaW4uZW1pdCgnUG9vbENhcHBlZCcsIHRoaXMuTUFYX1BPT0wpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICB0aGlzLnN0b3JhZ2UucHJpemVQb29sICs9IHBvb2xBbXQ7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAocHJvakFtdCA+IDAgJiYgdGhpcy5zdG9yYWdlLnByb2plY3RXYWxsZXQpIHsKICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tjaGFpbi50cmFuc2Zlcih0aGlzLnN0b3JhZ2UucHJvamVjdFdhbGxldCwgcHJvakFtdCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8gQ3JlYXRlIHRpY2tldAogICAgICAgIGNvbnN0IHRpY2tldCA9IHsKICAgICAgICAgICAgcGxheWVyOiBjYWxsZXIsCiAgICAgICAgICAgIG1haW5OdW1iZXJzOiBudW1zLAogICAgICAgICAgICBlaWdodEJhbGw6IGViLAogICAgICAgICAgICBwdXJjaGFzZVRpbWU6IHRoaXMuYmxvY2tjaGFpbi50aW1lc3RhbXAsCiAgICAgICAgICAgIGhhc1dvbjogZmFsc2UsCiAgICAgICAgICAgIHByaXplQ2xhaW1lZDogZmFsc2UsCiAgICAgICAgICAgIGlzRnJlZTogdXNlRnJlZSwKICAgICAgICAgICAgY29tbWl0SGFzaDogY29tbWl0SGFzaAogICAgICAgIH07CiAgICAgICAgCiAgICAgICAgY29uc3QgaWQgPSB0aGlzLnRpY2tldHMubGVuZ3RoOwogICAgICAgIHRoaXMudGlja2V0cy5wdXNoKHRpY2tldCk7CiAgICAgICAgCiAgICAgICAgaWYgKCF0aGlzLnBsYXllclRpY2tldElkc1tjYWxsZXJdKSB7CiAgICAgICAgICAgIHRoaXMucGxheWVyVGlja2V0SWRzW2NhbGxlcl0gPSBbXTsKICAgICAgICB9CiAgICAgICAgdGhpcy5wbGF5ZXJUaWNrZXRJZHNbY2FsbGVyXS5wdXNoKGlkKTsKICAgICAgICAKICAgICAgICB0aGlzLnN0b3JhZ2UudG90YWxUaWNrZXRzU29sZCsrOwogICAgICAgIAogICAgICAgIHRoaXMuYmxvY2tjaGFpbi5lbWl0KCdUaWNrZXRSZXZlYWxlZCcsIHsgaWQsIHBsYXllcjogY2FsbGVyLCBudW1zLCBlYiwgaXNGcmVlOiB1c2VGcmVlIH0pOwogICAgfQogICAgCiAgICAvKioKICAgICAqIEdlbmVyYXRlIGNvbW1pdCBoYXNoIGZyb20gbnVtYmVycywgZWIsIGFuZCBzYWx0CiAgICAgKi8KICAgIGhhc2hDb21taXQobnVtcywgZWIsIHNhbHQpIHsKICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5zdHJpbmdpZnkoeyBudW1zLCBlYiwgc2FsdCwgcGxheWVyOiB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyIH0pOwogICAgICAgIGxldCBoYXNoID0gMDsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgY2hhciA9IGRhdGEuY2hhckNvZGVBdChpKTsKICAgICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hhcjsKICAgICAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOwogICAgICAgIH0KICAgICAgICByZXR1cm4gJzB4JyArIE1hdGguYWJzKGhhc2gpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTsKICAgIH0KICAgIAogICAgLyoqCiAgICAgKiBHZW5lcmF0ZSByYW5kb20gbnVtYmVycyB1c2luZyBzZWN1cmUgUk5HCiAgICAgKi8KICAgIGdlbmVyYXRlU2VjdXJlUmFuZG9tTnVtYmVycygpIHsKICAgICAgICBjb25zdCBzZWVkID0gZ2VuZXJhdGVTZWVkKHRoaXMuYmxvY2tjaGFpbik7CiAgICAgICAgY29uc3QgbnVtcyA9IFtdOwogICAgICAgIGNvbnN0IHVzZWQgPSB7fTsKICAgICAgICAKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuTUFJTl9DT1VOVDsgaSsrKSB7CiAgICAgICAgICAgIGxldCBudW07CiAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIGNvbnN0IHJhbmQgPSBzZWN1cmVSYW5kb20oc2VlZCArIGkpOwogICAgICAgICAgICAgICAgbnVtID0gKHJhbmQgJSB0aGlzLk1BSU5fUkFOR0UpICsgMTsKICAgICAgICAgICAgfSB3aGlsZSAodXNlZFtudW1dKTsKICAgICAgICAgICAgdXNlZFtudW1dID0gdHJ1ZTsKICAgICAgICAgICAgbnVtcy5wdXNoKG51bSk7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIG51bXMuc29ydCgoYSwgYikgPT4gYSAtIGIpOwogICAgICAgIAogICAgICAgIGNvbnN0IGViID0gKHNlY3VyZVJhbmRvbShzZWVkICsgMTAwKSAlIHRoaXMuRUlHSFRfUkFOR0UpICsgMTsKICAgICAgICAKICAgICAgICByZXR1cm4geyBudW1zLCBlYiB9OwogICAgfQogICAgCiAgICAvKioKICAgICAqIEJ1eSB0aWNrZXQgd2l0aCBudW1iZXJzIChzaW1wbGlmaWVkIC0gd2l0aG91dCBjb21taXQtcmV2ZWFsIGZvciBzbWFsbCBwdXJjaGFzZXMpCiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBudW1zIC0gNSBtYWluIG51bWJlcnMgKDEtNTApCiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWIgLSBFaWdodCBiYWxsIG51bWJlciAoMS0yMCkKICAgICAqLwogICAgYnV5VGlja2V0KG51bXMsIGViKSB7CiAgICAgICAgY29uc3QgY2xlYW51cCA9IHRoaXMubm9uUmVlbnRyYW50KCdidXlUaWNrZXQnKTsKICAgICAgICB0cnkgewogICAgICAgICAgICBjb25zdCBjYWxsZXIgPSB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5yZXF1aXJlKHRoaXMuc3RvcmFnZS5yb3VuZEFjdGl2ZSwgJ1JvdW5kIG5vdCBhY3RpdmUnKTsKICAgICAgICAgICAgdGhpcy5yZXF1aXJlKGViID49IDEgJiYgZWIgPD0gdGhpcy5FSUdIVF9SQU5HRSwgJ0VpZ2h0IGJhbGwgMS0yMCcpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gVmFsaWRhdGUgbnVtYmVycwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuTUFJTl9DT1VOVDsgaSsrKSB7CiAgICAgICAgICAgICAgICB0aGlzLnJlcXVpcmUobnVtc1tpXSA+PSAxICYmIG51bXNbaV0gPD0gdGhpcy5NQUlOX1JBTkdFLCAnTnVtYmVycyAxLTUwJyk7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB0aGlzLk1BSU5fQ09VTlQ7IGorKykgewogICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWlyZShudW1zW2ldICE9PSBudW1zW2pdLCAnRHVwbGljYXRlIG51bWJlcnMnKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgbGV0IHVzZUZyZWUgPSBmYWxzZTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIENoZWNrIGZyZWUgY3JlZGl0cwogICAgICAgICAgICBpZiAodGhpcy5mcmVlVGlja2V0Q3JlZGl0c1tjYWxsZXJdID4gMCAmJiB0aGlzLmJsb2NrY2hhaW4udmFsdWUgPT09IDApIHsKICAgICAgICAgICAgICAgIHVzZUZyZWUgPSB0cnVlOwogICAgICAgICAgICAgICAgdGhpcy5mcmVlVGlja2V0Q3JlZGl0c1tjYWxsZXJdLS07CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLnJlcXVpcmUodGhpcy5ibG9ja2NoYWluLnZhbHVlID09PSB0aGlzLlRJQ0tFVF9QUklDRSwgJ011c3Qgc2VuZCAxMDAgS0xWJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGxldCBwb29sQW10ID0gMDsKICAgICAgICAgICAgbGV0IHByb2pBbXQgPSAwOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKCF1c2VGcmVlKSB7CiAgICAgICAgICAgICAgICBwb29sQW10ID0gKHRoaXMuVElDS0VUX1BSSUNFICogODUpIC8gMTAwOwogICAgICAgICAgICAgICAgcHJvakFtdCA9IHRoaXMuVElDS0VUX1BSSUNFIC0gcG9vbEFtdDsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5wcml6ZVBvb2wgKyBwb29sQW10ID4gdGhpcy5NQVhfUE9PTCkgewogICAgICAgICAgICAgICAgICAgIHBvb2xBbXQgPSB0aGlzLk1BWF9QT09MIC0gdGhpcy5zdG9yYWdlLnByaXplUG9vbDsKICAgICAgICAgICAgICAgICAgICBwcm9qQW10ID0gdGhpcy5USUNLRVRfUFJJQ0UgLSBwb29sQW10OwogICAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tjaGFpbi5lbWl0KCdQb29sQ2FwcGVkJywgdGhpcy5NQVhfUE9PTCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5wcml6ZVBvb2wgKz0gcG9vbEFtdDsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKHByb2pBbXQgPiAwICYmIHRoaXMuc3RvcmFnZS5wcm9qZWN0V2FsbGV0KSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9ja2NoYWluLnRyYW5zZmVyKHRoaXMuc3RvcmFnZS5wcm9qZWN0V2FsbGV0LCBwcm9qQW10KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLy8gQ3JlYXRlIHRpY2tldAogICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB7CiAgICAgICAgICAgICAgICBwbGF5ZXI6IGNhbGxlciwKICAgICAgICAgICAgICAgIG1haW5OdW1iZXJzOiBudW1zLAogICAgICAgICAgICAgICAgZWlnaHRCYWxsOiBlYiwKICAgICAgICAgICAgICAgIHB1cmNoYXNlVGltZTogdGhpcy5ibG9ja2NoYWluLnRpbWVzdGFtcCwKICAgICAgICAgICAgICAgIGhhc1dvbjogZmFsc2UsCiAgICAgICAgICAgICAgICBwcml6ZUNsYWltZWQ6IGZhbHNlLAogICAgICAgICAgICAgICAgaXNGcmVlOiB1c2VGcmVlCiAgICAgICAgICAgIH07CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMudGlja2V0cy5sZW5ndGg7CiAgICAgICAgICAgIHRoaXMudGlja2V0cy5wdXNoKHRpY2tldCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAoIXRoaXMucGxheWVyVGlja2V0SWRzW2NhbGxlcl0pIHsKICAgICAgICAgICAgICAgIHRoaXMucGxheWVyVGlja2V0SWRzW2NhbGxlcl0gPSBbXTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnBsYXllclRpY2tldElkc1tjYWxsZXJdLnB1c2goaWQpOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnRvdGFsVGlja2V0c1NvbGQrKzsKICAgICAgICAgICAgCiAgICAgICAgICAgIHRoaXMuYmxvY2tjaGFpbi5lbWl0KCdUaWNrZXRQdXJjaGFzZWQnLCB7IGlkLCBwbGF5ZXI6IGNhbGxlciwgbnVtcywgZWIsIGlzRnJlZTogdXNlRnJlZSB9KTsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBjbGVhbnVwKCk7CiAgICAgICAgfQogICAgfQogICAgCiAgICAvKioKICAgICAqIFF1aWNrIHBpY2sgLSB1c2VzIHNlY3VyZSByYW5kb20gbnVtYmVycwogICAgICovCiAgICBxdWlja1BpY2soKSB7CiAgICAgICAgY29uc3QgY2xlYW51cCA9IHRoaXMubm9uUmVlbnRyYW50KCdxdWlja1BpY2snKTsKICAgICAgICB0cnkgewogICAgICAgICAgICBjb25zdCBjYWxsZXIgPSB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5yZXF1aXJlKHRoaXMuc3RvcmFnZS5yb3VuZEFjdGl2ZSwgJ1JvdW5kIG5vdCBhY3RpdmUnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHsgbnVtcywgZWIgfSA9IHRoaXMuZ2VuZXJhdGVTZWN1cmVSYW5kb21OdW1iZXJzKCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAodGhpcy5mcmVlVGlja2V0Q3JlZGl0c1tjYWxsZXJdID4gMCAmJiB0aGlzLmJsb2NrY2hhaW4udmFsdWUgPT09IDApIHsKICAgICAgICAgICAgICAgIHRoaXMuZnJlZVRpY2tldENyZWRpdHNbY2FsbGVyXS0tOwogICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmVlVGlja2V0KG51bXMsIGViKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLmJsb2NrY2hhaW4udmFsdWUgPT09IHRoaXMuVElDS0VUX1BSSUNFLCAnTXVzdCBzZW5kIDEwMCBLTFYnKTsKICAgICAgICAgICAgICAgIHRoaXMuYnV5VGlja2V0KG51bXMsIGViKTsKICAgICAgICAgICAgfQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGNsZWFudXAoKTsKICAgICAgICB9CiAgICB9CiAgICAKICAgIC8qKgogICAgICogQ2xhaW0gZGFpbHkgZnJlZSB0aWNrZXRzIChiYXNlZCBvbiBzdGFraW5nKQogICAgICovCiAgICBjbGFpbUZyZWVUaWNrZXRzKCkgewogICAgICAgIGNvbnN0IGNhbGxlciA9IHRoaXMuYmxvY2tjaGFpbi5jYWxsZXI7CiAgICAgICAgCiAgICAgICAgdGhpcy5yZXF1aXJlKHRoaXMuc3RvcmFnZS5yb3VuZEFjdGl2ZSwgJ1JvdW5kIG5vdCBhY3RpdmUnKTsKICAgICAgICB0aGlzLnJlcXVpcmUodGhpcy5zdG9yYWdlLmtwZXBlU3Rha2luZywgJ1N0YWtpbmcgY29udHJhY3Qgbm90IHNldCcpOwogICAgICAgIAogICAgICAgIC8vIENoZWNrIGlmIG5ldyBkcmF3IG9jY3VycmVkCiAgICAgICAgY29uc3QgY3VycmVudERheSA9IE1hdGguZmxvb3IodGhpcy5ibG9ja2NoYWluLnRpbWVzdGFtcCAvIDg2NDAwKTsKICAgICAgICBjb25zdCBsYXN0RHJhd0RheSA9IE1hdGguZmxvb3IodGhpcy5zdG9yYWdlLmxhc3REcmF3VGltZSAvIDg2NDAwKTsKICAgICAgICAKICAgICAgICBpZiAoY3VycmVudERheSA+IGxhc3REcmF3RGF5KSB7CiAgICAgICAgICAgIHRoaXMuZXhwaXJlQWxsRnJlZVRpY2tldHMoKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgLy8gVHJhY2sgcGxheWVyCiAgICAgICAgaWYgKCF0aGlzLmlzRnJlZVRpY2tldFBsYXllcltjYWxsZXJdKSB7CiAgICAgICAgICAgIHRoaXMuaXNGcmVlVGlja2V0UGxheWVyW2NhbGxlcl0gPSB0cnVlOwogICAgICAgICAgICB0aGlzLmZyZWVUaWNrZXRQbGF5ZXJzLnB1c2goY2FsbGVyKTsKICAgICAgICB9CiAgICAgICAgCiAgICAgICAgdGhpcy5mcmVlVGlja2V0Q3JlZGl0c1tjYWxsZXJdKys7CiAgICAgICAgdGhpcy5sYXN0RnJlZVRpY2tldENsYWltW2NhbGxlcl0gPSB0aGlzLmJsb2NrY2hhaW4udGltZXN0YW1wOwogICAgICAgIAogICAgICAgIHRoaXMuYmxvY2tjaGFpbi5lbWl0KCdGcmVlVGlja2V0c0NsYWltZWQnLCB7IHBsYXllcjogY2FsbGVyLCBhbW91bnQ6IDEgfSk7CiAgICB9CiAgICAKICAgIC8qKgogICAgICogR2V0IGZyZWUgdGlja2V0cyBhdmFpbGFibGUKICAgICAqLwogICAgZ2V0RnJlZVRpY2tldHNBdmFpbGFibGUoKSB7CiAgICAgICAgY29uc3QgY2FsbGVyID0gdGhpcy5ibG9ja2NoYWluLmNhbGxlcjsKICAgICAgICAKICAgICAgICBjb25zdCBjdXJyZW50RGF5ID0gTWF0aC5mbG9vcih0aGlzLmJsb2NrY2hhaW4udGltZXN0YW1wIC8gODY0MDApOwogICAgICAgIGNvbnN0IGxhc3REcmF3RGF5ID0gTWF0aC5mbG9vcih0aGlzLnN0b3JhZ2UubGFzdERyYXdUaW1lIC8gODY0MDApOwogICAgICAgIAogICAgICAgIGlmIChjdXJyZW50RGF5ID4gbGFzdERyYXdEYXkpIHsKICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIHJldHVybiB0aGlzLmZyZWVUaWNrZXRDcmVkaXRzW2NhbGxlcl0gfHwgMDsKICAgIH0KICAgIAogICAgLyoqCiAgICAgKiBTdGFydCB0aGUgZHJhdwogICAgICovCiAgICBzdGFydERyYXcoKSB7CiAgICAgICAgY29uc3QgY2FsbGVyID0gdGhpcy5ibG9ja2NoYWluLmNhbGxlcjsKICAgICAgICAKICAgICAgICB0aGlzLnJlcXVpcmUoIXRoaXMuc3RvcmFnZS5kcmF3SW5Qcm9ncmVzcywgJ0RyYXcgYWxyZWFkeSBpbiBwcm9ncmVzcycpOwogICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLnRpY2tldHMubGVuZ3RoID4gMCwgJ05vIHRpY2tldHMgdG8gZHJhdycpOwogICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLnN0b3JhZ2Uucm91bmRBY3RpdmUsICdSb3VuZCBub3QgYWN0aXZlJyk7CiAgICAgICAgCiAgICAgICAgdGhpcy5zdG9yYWdlLmRyYXdJblByb2dyZXNzID0gdHJ1ZTsKICAgICAgICB0aGlzLmJsb2NrY2hhaW4uZW1pdCgnRHJhd1N0YXJ0ZWQnLCB0aGlzLmJsb2NrY2hhaW4udGltZXN0YW1wKTsKICAgIH0KICAgIAogICAgLyoqCiAgICAgKiBDb21wbGV0ZSB0aGUgZHJhdyAtIG93bmVyIG9ubHkKICAgICAqLwogICAgY29tcGxldGVEcmF3KCkgewogICAgICAgIGNvbnN0IGNsZWFudXAgPSB0aGlzLm5vblJlZW50cmFudCgnY29tcGxldGVEcmF3Jyk7CiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgY29uc3QgY2FsbGVyID0gdGhpcy5ibG9ja2NoYWluLmNhbGxlcjsKICAgICAgICAgICAgCiAgICAgICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLmJsb2NrY2hhaW4uaXNPd25lcihjYWxsZXIpLCAnTm90IG93bmVyJyk7CiAgICAgICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLnN0b3JhZ2UuZHJhd0luUHJvZ3Jlc3MsICdObyBkcmF3IGluIHByb2dyZXNzJyk7CiAgICAgICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLnRpY2tldHMubGVuZ3RoID4gMCwgJ05vIHRpY2tldHMnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHdpbm5pbmcgbnVtYmVycyB1c2luZyBzZWN1cmUgUk5HCiAgICAgICAgICAgIGNvbnN0IHsgbnVtcywgZWIgfSA9IHRoaXMuZ2VuZXJhdGVTZWN1cmVSYW5kb21OdW1iZXJzKCk7CiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS53aW5uaW5nTnVtYmVycyA9IG51bXM7CiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS53aW5uaW5nRWlnaHRCYWxsID0gZWI7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBEaXN0cmlidXRlIHByaXplcwogICAgICAgICAgICBjb25zdCB3aW5uZXJzID0gdGhpcy5kaXN0cmlidXRlUHJpemVzKCk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBVcGRhdGUgcG9vbAogICAgICAgICAgICB0aGlzLnN0b3JhZ2UucHJpemVQb29sID0gTWF0aC5mbG9vcih0aGlzLnN0b3JhZ2UucHJpemVQb29sICogdGhpcy5QT09MX1JFVEVOVElPTiAvIDEwMDAwKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIEV4cGlyZSBmcmVlIHRpY2tldHMKICAgICAgICAgICAgdGhpcy5leHBpcmVBbGxGcmVlVGlja2V0cygpOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRyYXdJblByb2dyZXNzID0gZmFsc2U7CiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5sYXN0RHJhd1RpbWUgPSB0aGlzLmJsb2NrY2hhaW4udGltZXN0YW1wOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5ibG9ja2NoYWluLmVtaXQoJ0RyYXdDb21wbGV0ZWQnLCB7CiAgICAgICAgICAgICAgICB3aW5uaW5nTnVtYmVyczogdGhpcy5zdG9yYWdlLndpbm5pbmdOdW1iZXJzLAogICAgICAgICAgICAgICAgd2lubmluZ0VpZ2h0QmFsbDogdGhpcy5zdG9yYWdlLndpbm5pbmdFaWdodEJhbGwsCiAgICAgICAgICAgICAgICBwb29sOiB0aGlzLnN0b3JhZ2UucHJpemVQb29sLAogICAgICAgICAgICAgICAgd2lubmVyczogd2lubmVycwogICAgICAgICAgICB9KTsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBjbGVhbnVwKCk7CiAgICAgICAgfQogICAgfQogICAgCiAgICAvKioKICAgICAqIENsYWltIHByaXplIGZvciBhIHNwZWNpZmljIHRpY2tldAogICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gVGlja2V0IElECiAgICAgKi8KICAgIGNsYWltUHJpemUoaWQpIHsKICAgICAgICBjb25zdCBjbGVhbnVwID0gdGhpcy5ub25SZWVudHJhbnQoJ2NsYWltUHJpemUnKTsKICAgICAgICB0cnkgewogICAgICAgICAgICBjb25zdCBjYWxsZXIgPSB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5yZXF1aXJlKGlkIDwgdGhpcy50aWNrZXRzLmxlbmd0aCwgJ0ludmFsaWQgdGlja2V0Jyk7CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB0aGlzLnRpY2tldHNbaWRdOwogICAgICAgICAgICB0aGlzLnJlcXVpcmUodGlja2V0LnBsYXllciA9PT0gY2FsbGVyLCAnTm90IHlvdXIgdGlja2V0Jyk7CiAgICAgICAgICAgIHRoaXMucmVxdWlyZSh0aWNrZXQuaGFzV29uLCAnVGlja2V0IGRpZCBub3Qgd2luJyk7CiAgICAgICAgICAgIHRoaXMucmVxdWlyZSghdGlja2V0LnByaXplQ2xhaW1lZCwgJ1ByaXplIGFscmVhZHkgY2xhaW1lZCcpOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgdGllciA9IHRoaXMuY2FsY3VsYXRlVGllcih0aWNrZXQpOwogICAgICAgICAgICBjb25zdCBwcml6ZSA9IHRoaXMuY2FsY3VsYXRlUHJpemUodGllcik7CiAgICAgICAgICAgIAogICAgICAgICAgICB0aGlzLnJlcXVpcmUocHJpemUgPiAwLCAnTm8gcHJpemUnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHRpY2tldC5wcml6ZUNsYWltZWQgPSB0cnVlOwogICAgICAgICAgICB0aGlzLnN0b3JhZ2UucHJpemVQb29sIC09IHByaXplOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5ibG9ja2NoYWluLnRyYW5zZmVyKGNhbGxlciwgcHJpemUpOwogICAgICAgICAgICB0aGlzLmJsb2NrY2hhaW4uZW1pdCgnUHJpemVDbGFpbWVkJywgeyBwbGF5ZXI6IGNhbGxlciwgYW1vdW50OiBwcml6ZSB9KTsKICAgICAgICB9IGZpbmFsbHkgewogICAgICAgICAgICBjbGVhbnVwKCk7CiAgICAgICAgfQogICAgfQogICAgCiAgICAvKioKICAgICAqIENsYWltIHBlbmRpbmcgS1BFUEUgcHJpemVzCiAgICAgKi8KICAgIGNsYWltS1BFUEVQcml6ZSgpIHsKICAgICAgICBjb25zdCBjbGVhbnVwID0gdGhpcy5ub25SZWVudHJhbnQoJ2NsYWltS1BFUEVQcml6ZScpOwogICAgICAgIHRyeSB7CiAgICAgICAgICAgIGNvbnN0IGNhbGxlciA9IHRoaXMuYmxvY2tjaGFpbi5jYWxsZXI7CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gdGhpcy5rcGVwZVByaXplc1BlbmRpbmdbY2FsbGVyXSB8fCAwOwogICAgICAgICAgICB0aGlzLnJlcXVpcmUocGVuZGluZyA+IDAsICdObyBwZW5kaW5nIEtQRVBFJyk7CiAgICAgICAgICAgIAogICAgICAgICAgICB0aGlzLmtwZXBlUHJpemVzUGVuZGluZ1tjYWxsZXJdID0gMDsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFRyYW5zZmVyIEtQRVBFIHRva2VucwogICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmtwZXBlVG9rZW4pIHsKICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tjaGFpbi5jYWxsQ29udHJhY3QoCiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmtwZXBlVG9rZW4sCiAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZmVyJywKICAgICAgICAgICAgICAgICAgICBbY2FsbGVyLCBwZW5kaW5nXQogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5ibG9ja2NoYWluLmVtaXQoJ0tQRVBFUHJpemVDbGFpbWVkJywgeyBwbGF5ZXI6IGNhbGxlciwgYW1vdW50OiBwZW5kaW5nIH0pOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGNsZWFudXAoKTsKICAgICAgICB9CiAgICB9CiAgICAKICAgIC8qKgogICAgICogSW5pdGlhbGl6ZSB3YWxsZXRzIC0gY2FsbGVkIG9uY2UKICAgICAqLwogICAgaW5pdGlhbGl6ZVdhbGxldHMocHJvamVjdFdhbGxldCwgcHJpemVQb29sV2FsbGV0KSB7CiAgICAgICAgY29uc3QgY2FsbGVyID0gdGhpcy5ibG9ja2NoYWluLmNhbGxlcjsKICAgICAgICAKICAgICAgICB0aGlzLnJlcXVpcmUodGhpcy5ibG9ja2NoYWluLmlzT3duZXIoY2FsbGVyKSwgJ05vdCBvd25lcicpOwogICAgICAgIHRoaXMucmVxdWlyZSghdGhpcy5zdG9yYWdlLnByb2plY3RXYWxsZXQsICdBbHJlYWR5IGluaXRpYWxpemVkJyk7CiAgICAgICAgdGhpcy5yZXF1aXJlKHByb2plY3RXYWxsZXQgJiYgcHJpemVQb29sV2FsbGV0LCAnSW52YWxpZCB3YWxsZXRzJyk7CiAgICAgICAgCiAgICAgICAgdGhpcy5zdG9yYWdlLnByb2plY3RXYWxsZXQgPSBwcm9qZWN0V2FsbGV0OwogICAgICAgIHRoaXMuc3RvcmFnZS5wcml6ZVBvb2xXYWxsZXQgPSBwcml6ZVBvb2xXYWxsZXQ7CiAgICAgICAgCiAgICAgICAgdGhpcy5ibG9ja2NoYWluLmVtaXQoJ1dhbGxldHNJbml0aWFsaXplZCcsIHsgcHJvamVjdFdhbGxldCwgcHJpemVQb29sV2FsbGV0IH0pOwogICAgfQogICAgCiAgICAvKioKICAgICAqIFNldCBLUEVQRSB0b2tlbiBhZGRyZXNzCiAgICAgKi8KICAgIHNldEtQRVBFVG9rZW4odG9rZW4pIHsKICAgICAgICBjb25zdCBjYWxsZXIgPSB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyOwogICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLmJsb2NrY2hhaW4uaXNPd25lcihjYWxsZXIpLCAnTm90IG93bmVyJyk7CiAgICAgICAgdGhpcy5zdG9yYWdlLmtwZXBlVG9rZW4gPSB0b2tlbjsKICAgIH0KICAgIAogICAgLyoqCiAgICAgKiBTZXQgS1BFUEUgc3Rha2luZyBjb250cmFjdAogICAgICovCiAgICBzZXRLUEVQRVN0YWtpbmcoc3Rha2luZykgewogICAgICAgIGNvbnN0IGNhbGxlciA9IHRoaXMuYmxvY2tjaGFpbi5jYWxsZXI7CiAgICAgICAgdGhpcy5yZXF1aXJlKHRoaXMuYmxvY2tjaGFpbi5pc093bmVyKGNhbGxlciksICdOb3Qgb3duZXInKTsKICAgICAgICB0aGlzLnN0b3JhZ2Uua3BlcGVTdGFraW5nID0gc3Rha2luZzsKICAgIH0KICAgIAogICAgLyoqCiAgICAgKiBUb2dnbGUgcm91bmQgYWN0aXZlL2luYWN0aXZlCiAgICAgKi8KICAgIHRvZ2dsZVJvdW5kKCkgewogICAgICAgIGNvbnN0IGNhbGxlciA9IHRoaXMuYmxvY2tjaGFpbi5jYWxsZXI7CiAgICAgICAgdGhpcy5yZXF1aXJlKHRoaXMuYmxvY2tjaGFpbi5pc093bmVyKGNhbGxlciksICdOb3Qgb3duZXInKTsKICAgICAgICB0aGlzLnN0b3JhZ2Uucm91bmRBY3RpdmUgPSAhdGhpcy5zdG9yYWdlLnJvdW5kQWN0aXZlOwogICAgfQogICAgCiAgICAvKioKICAgICAqIFNldCBLUEVQRSBwcml6ZSBhbW91bnRzCiAgICAgKi8KICAgIHNldEtQRVBFUHJpemVzKGosIG01LCBtNDgsIG00LCBtMzgsIG0zLCBtMjgsIG0xOCwgbTgpIHsKICAgICAgICBjb25zdCBjYWxsZXIgPSB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyOwogICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLmJsb2NrY2hhaW4uaXNPd25lcihjYWxsZXIpLCAnTm90IG93bmVyJyk7CiAgICAgICAgCiAgICAgICAgdGhpcy5zdG9yYWdlLmtwZXBlSmFja3BvdFByaXplID0gajsKICAgICAgICB0aGlzLnN0b3JhZ2Uua3BlcGVNYXRjaDVQcml6ZSA9IG01OwogICAgICAgIHRoaXMuc3RvcmFnZS5rcGVwZU1hdGNoNDhCUHJpemUgPSBtNDg7CiAgICAgICAgdGhpcy5zdG9yYWdlLmtwZXBlTWF0Y2g0UHJpemUgPSBtNDsKICAgICAgICB0aGlzLnN0b3JhZ2Uua3BlcGVNYXRjaDM4QlByaXplID0gbTM4OwogICAgICAgIHRoaXMuc3RvcmFnZS5rcGVwZU1hdGNoM1ByaXplID0gbTM7CiAgICAgICAgdGhpcy5zdG9yYWdlLmtwZXBlTWF0Y2gyOEJQcml6ZSA9IG0yODsKICAgICAgICB0aGlzLnN0b3JhZ2Uua3BlcGVNYXRjaDE4QlByaXplID0gbTE4OwogICAgICAgIHRoaXMuc3RvcmFnZS5rcGVwZU1hdGNoOEJPbmx5UHJpemUgPSBtODsKICAgIH0KICAgIAogICAgLyoqCiAgICAgKiBXaXRoZHJhdyBmcm9tIHByaXplIHBvb2wgKG1heCAxMCUpCiAgICAgKi8KICAgIHdpdGhkcmF3UHJpemVQb29sKGFtb3VudCkgewogICAgICAgIGNvbnN0IGNsZWFudXAgPSB0aGlzLm5vblJlZW50cmFudCgnd2l0aGRyYXdQcml6ZVBvb2wnKTsKICAgICAgICB0cnkgewogICAgICAgICAgICBjb25zdCBjYWxsZXIgPSB0aGlzLmJsb2NrY2hhaW4uY2FsbGVyOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5yZXF1aXJlKHRoaXMuYmxvY2tjaGFpbi5pc093bmVyKGNhbGxlciksICdOb3Qgb3duZXInKTsKICAgICAgICAgICAgdGhpcy5yZXF1aXJlKGFtb3VudCA8PSB0aGlzLnN0b3JhZ2UucHJpemVQb29sLCAnSW5zdWZmaWNpZW50IGJhbGFuY2UnKTsKICAgICAgICAgICAgdGhpcy5yZXF1aXJlKGFtb3VudCA8PSB0aGlzLnN0b3JhZ2UucHJpemVQb29sIC8gMTAsICdNYXggMTAlJyk7CiAgICAgICAgICAgIHRoaXMucmVxdWlyZSh0aGlzLnN0b3JhZ2UucHJpemVQb29sV2FsbGV0LCAnUHJpemUgd2FsbGV0IG5vdCBzZXQnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5wcml6ZVBvb2wgLT0gYW1vdW50OwogICAgICAgICAgICB0aGlzLmJsb2NrY2hhaW4udHJhbnNmZXIodGhpcy5zdG9yYWdlLnByaXplUG9vbFdhbGxldCwgYW1vdW50KTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHRoaXMuYmxvY2tjaGFpbi5lbWl0KCdQcml6ZVBvb2xXaXRoZHJhd24nLCBhbW91bnQpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICAgIGNsZWFudXAoKTsKICAgICAgICB9CiAgICB9CiAgICAKICAgIC8vID09PT09IFZJRVcgRlVOQ1RJT05TID09PT09CiAgICAKICAgIGdldFBvb2xCYWxhbmNlKCkgewogICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2UucHJpemVQb29sOwogICAgfQogICAgCiAgICBnZXROZXh0RHJhd1RpbWUoKSB7CiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5zdG9yYWdlLmxhc3REcmF3VGltZSAvIDg2NDAwICsgMSkgKiA4NjQwMDsKICAgIH0KICAgIAogICAgZ2V0VGlja2V0KGlkKSB7CiAgICAgICAgaWYgKGlkID49IHRoaXMudGlja2V0cy5sZW5ndGgpIHJldHVybiBudWxsOwogICAgICAgIHJldHVybiB0aGlzLnRpY2tldHNbaWRdOwogICAgfQogICAgCiAgICBjaGVja1RpY2tldFJlc3VsdChpZCkgewogICAgICAgIGNvbnN0IHRpY2tldCA9IHRoaXMuZ2V0VGlja2V0KGlkKTsKICAgICAgICBpZiAoIXRpY2tldCkgcmV0dXJuIHsgdGllcjogMCwgcHJpemU6IDAgfTsKICAgICAgICAKICAgICAgICBjb25zdCB0aWVyID0gdGhpcy5jYWxjdWxhdGVUaWVyKHRpY2tldCk7CiAgICAgICAgY29uc3QgcHJpemUgPSB0aWVyID4gMCA/IHRoaXMuY2FsY3VsYXRlUHJpemUodGllcikgOiAwOwogICAgICAgIAogICAgICAgIHJldHVybiB7IHRpZXIsIHByaXplIH07CiAgICB9CiAgICAKICAgIGdldFBsYXllclRpY2tldHMoYWRkcmVzcykgewogICAgICAgIHJldHVybiB0aGlzLnBsYXllclRpY2tldElkc1thZGRyZXNzXSB8fCBbXTsKICAgIH0KICAgIAogICAgLy8gPT09PT0gSU5URVJOQUwgSEVMUEVSUyA9IwogICAgCiAgICBnZW5lcmF0ZVdpbm5pbmdOdW1iZXJzKCkgewogICAgICAgIGNvbnN0IHsgbnVtcywgZWIgfSA9IHRoaXMuZ2VuZXJhdGVTZWN1cmVSYW5kb21OdW1iZXJzKCk7CiAgICAgICAgdGhpcy5zdG9yYWdlLndpbm5pbmdOdW1iZXJzID0gbnVtczsKICAgICAgICB0aGlzLnN0b3JhZ2Uud2lubmluZ0VpZ2h0QmFsbCA9IGViOwogICAgfQogICAgCiAgICBjYWxjdWxhdGVUaWVyKHRpY2tldCkgewogICAgICAgIGxldCBtYXRjaGVzID0gMDsKICAgICAgICAKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuTUFJTl9DT1VOVDsgaSsrKSB7CiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5NQUlOX0NPVU5UOyBqKyspIHsKICAgICAgICAgICAgICAgIGlmICh0aWNrZXQubWFpbk51bWJlcnNbaV0gPT09IHRoaXMuc3RvcmFnZS53aW5uaW5nTnVtYmVyc1tqXSkgewogICAgICAgICAgICAgICAgICAgIG1hdGNoZXMrKzsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAKICAgICAgICBjb25zdCBlYk1hdGNoID0gdGlja2V0LmVpZ2h0QmFsbCA9PT0gdGhpcy5zdG9yYWdlLndpbm5pbmdFaWdodEJhbGw7CiAgICAgICAgCiAgICAgICAgaWYgKG1hdGNoZXMgPT09IDUgJiYgZWJNYXRjaCkgcmV0dXJuIDE7ICAvLyBKYWNrcG90CiAgICAgICAgaWYgKG1hdGNoZXMgPT09IDUpIHJldHVybiAyOyAgICAgICAgICAgICAvLyBNYXRjaCA1CiAgICAgICAgaWYgKG1hdGNoZXMgPT09IDQgJiYgZWJNYXRjaCkgcmV0dXJuIDM7ICAvLyA0ICsgOEIKICAgICAgICBpZiAobWF0Y2hlcyA9PT0gNCkgcmV0dXJuIDQ7ICAgICAgICAgICAgIC8vIE1hdGNoIDQKICAgICAgICBpZiAobWF0Y2hlcyA9PT0gMyAmJiBlYk1hdGNoKSByZXR1cm4gNTsgIC8vIDMgKyA4QgogICAgICAgIGlmIChtYXRjaGVzID09PSAzKSByZXR1cm4gNjsgICAgICAgICAgICAgLy8gTWF0Y2ggMwogICAgICAgIGlmIChtYXRjaGVzID09PSAyICYmIGViTWF0Y2gpIHJldHVybiA3OyAgLy8gMiArIDhCCiAgICAgICAgaWYgKG1hdGNoZXMgPT09IDEgJiYgZWJNYXRjaCkgcmV0dXJuIDg7ICAvLyAxICsgOEIKICAgICAgICBpZiAoZWJNYXRjaCkgcmV0dXJuIDk7ICAgICAgICAgICAgICAgICAgIC8vIDhCIG9ubHkKICAgICAgICAKICAgICAgICByZXR1cm4gMDsKICAgIH0KICAgIAogICAgY2FsY3VsYXRlUHJpemUodGllcikgewogICAgICAgIGxldCBwY3QgPSAwOwogICAgICAgIAogICAgICAgIHN3aXRjaCAodGllcikgewogICAgICAgICAgICBjYXNlIDE6IHBjdCA9IHRoaXMuUFJJWkVfSkFDS1BPVDsgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjogcGN0ID0gdGhpcy5QUklaRV9NQVRDSDU7IGJyZWFrOwogICAgICAgICAgICBjYXNlIDM6IHBjdCA9IHRoaXMuUFJJWkVfNF84QjsgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNDogcGN0ID0gdGhpcy5QUklaRV80OyBicmVhazsKICAgICAgICAgICAgY2FzZSA1OiBwY3QgPSB0aGlzLlBSSVpFXzNfOEI7IGJyZWFrOwogICAgICAgICAgICBjYXNlIDY6IHBjdCA9IHRoaXMuUFJJWkVfMzsgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNzogcGN0ID0gdGhpcy5QUklaRV8yXzhCOyBicmVhazsKICAgICAgICAgICAgY2FzZSA4OiBwY3QgPSB0aGlzLlBSSVpFXzFfOEI7IGJyZWFrOwogICAgICAgICAgICBjYXNlIDk6IHBjdCA9IHRoaXMuUFJJWkVfOEJfT05MWTsgYnJlYWs7CiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiAwOwogICAgICAgIH0KICAgICAgICAKICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnN0b3JhZ2UucHJpemVQb29sICogcGN0IC8gMTAwMDApOwogICAgfQogICAgCiAgICBjYWxjdWxhdGVLUEVQRSh0aWVyKSB7CiAgICAgICAgc3dpdGNoICh0aWVyKSB7CiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIHRoaXMuc3RvcmFnZS5rcGVwZUphY2twb3RQcml6ZTsKICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gdGhpcy5zdG9yYWdlLmtwZXBlTWF0Y2g1UHJpemU7CiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRoaXMuc3RvcmFnZS5rcGVwZU1hdGNoNDhCUHJpemU7CiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIHRoaXMuc3RvcmFnZS5rcGVwZU1hdGNoNFByaXplOwogICAgICAgICAgICBjYXNlIDU6IHJldHVybiB0aGlzLnN0b3JhZ2Uua3BlcGVNYXRjaDM4QlByaXplOwogICAgICAgICAgICBjYXNlIDY6IHJldHVybiB0aGlzLnN0b3JhZ2Uua3BlcGVNYXRjaDNQcml6ZTsKICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gdGhpcy5zdG9yYWdlLmtwZXBlTWF0Y2gyOEJQcml6ZTsKICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gdGhpcy5zdG9yYWdlLmtwZXBlTWF0Y2gxOEJQcml6ZTsKICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gdGhpcy5zdG9yYWdlLmtwZXBlTWF0Y2g4Qk9ubHlQcml6ZTsKICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIDA7CiAgICAgICAgfQogICAgfQogICAgCiAgICBkaXN0cmlidXRlUHJpemVzKCkgewogICAgICAgIGxldCB3aW5uZXJzID0gMDsKICAgICAgICAKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGlja2V0cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB0aGlzLnRpY2tldHNbaV07CiAgICAgICAgICAgIGlmICh0aWNrZXQucHJpemVDbGFpbWVkKSBjb250aW51ZTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHRpZXIgPSB0aGlzLmNhbGN1bGF0ZVRpZXIodGlja2V0KTsKICAgICAgICAgICAgaWYgKHRpZXIgPiAwKSB7CiAgICAgICAgICAgICAgICBjb25zdCBwcml6ZSA9IHRoaXMuY2FsY3VsYXRlUHJpemUodGllcik7CiAgICAgICAgICAgICAgICBpZiAocHJpemUgPiAwICYmIHByaXplIDw9IHRoaXMuc3RvcmFnZS5wcml6ZVBvb2wpIHsKICAgICAgICAgICAgICAgICAgICB0aWNrZXQuaGFzV29uID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICB0aWNrZXQucHJpemVDbGFpbWVkID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UucHJpemVQb29sIC09IHByaXplOwogICAgICAgICAgICAgICAgICAgIHdpbm5lcnMrKzsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrY2hhaW4udHJhbnNmZXIodGlja2V0LnBsYXllciwgcHJpemUpOwogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBLUEVQRSBwcml6ZQogICAgICAgICAgICAgICAgICAgIGNvbnN0IGtwID0gdGhpcy5jYWxjdWxhdGVLUEVQRSh0aWVyKTsKICAgICAgICAgICAgICAgICAgICBpZiAoa3AgPiAwICYmIHRoaXMuc3RvcmFnZS5rcGVwZVRva2VuKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua3BlcGVQcml6ZXNQZW5kaW5nW3RpY2tldC5wbGF5ZXJdID0gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5rcGVwZVByaXplc1BlbmRpbmdbdGlja2V0LnBsYXllcl0gfHwgMCkgKyBrcDsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9ja2NoYWluLmVtaXQoJ1ByaXplRGlzdHJpYnV0ZWQnLCB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcjogdGlja2V0LnBsYXllciwKICAgICAgICAgICAgICAgICAgICAgICAgdGlja2V0SWQ6IGksCiAgICAgICAgICAgICAgICAgICAgICAgIHRpZXIsCiAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogcHJpemUKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAKICAgICAgICByZXR1cm4gd2lubmVyczsKICAgIH0KICAgIAogICAgY3JlYXRlRnJlZVRpY2tldChudW1zLCBlYikgewogICAgICAgIGNvbnN0IGNhbGxlciA9IHRoaXMuYmxvY2tjaGFpbi5jYWxsZXI7CiAgICAgICAgCiAgICAgICAgY29uc3QgdGlja2V0ID0gewogICAgICAgICAgICBwbGF5ZXI6IGNhbGxlciwKICAgICAgICAgICAgbWFpbk51bWJlcnM6IG51bXMsCiAgICAgICAgICAgIGVpZ2h0QmFsbDogZWIsCiAgICAgICAgICAgIHB1cmNoYXNlVGltZTogdGhpcy5ibG9ja2NoYWluLnRpbWVzdGFtcCwKICAgICAgICAgICAgaGFzV29uOiBmYWxzZSwKICAgICAgICAgICAgcHJpemVDbGFpbWVkOiBmYWxzZSwKICAgICAgICAgICAgaXNGcmVlOiB0cnVlCiAgICAgICAgfTsKICAgICAgICAKICAgICAgICBjb25zdCBpZCA9IHRoaXMudGlja2V0cy5sZW5ndGg7CiAgICAgICAgdGhpcy50aWNrZXRzLnB1c2godGlja2V0KTsKICAgICAgICAKICAgICAgICBpZiAoIXRoaXMucGxheWVyVGlja2V0SWRzW2NhbGxlcl0pIHsKICAgICAgICAgICAgdGhpcy5wbGF5ZXJUaWNrZXRJZHNbY2FsbGVyXSA9IFtdOwogICAgICAgIH0KICAgICAgICB0aGlzLnBsYXllclRpY2tldElkc1tjYWxsZXJdLnB1c2goaWQpOwogICAgICAgIAogICAgICAgIHRoaXMuc3RvcmFnZS50b3RhbFRpY2tldHNTb2xkKys7CiAgICAgICAgCiAgICAgICAgdGhpcy5ibG9ja2NoYWluLmVtaXQoJ1RpY2tldFB1cmNoYXNlZCcsIHsgaWQsIHBsYXllcjogY2FsbGVyLCBudW1zLCBlYiwgaXNGcmVlOiB0cnVlIH0pOwogICAgfQogICAgCiAgICBleHBpcmVBbGxGcmVlVGlja2V0cygpIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnJlZVRpY2tldFBsYXllcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5mcmVlVGlja2V0UGxheWVyc1tpXTsKICAgICAgICAgICAgdGhpcy5mcmVlVGlja2V0Q3JlZGl0c1twbGF5ZXJdID0gMDsKICAgICAgICB9CiAgICAgICAgdGhpcy5mcmVlVGlja2V0UGxheWVycyA9IFtdOwogICAgfQogICAgCiAgICAvKioKICAgICAqIEZhbGxiYWNrIC0gYWNjZXB0IEtMViBkZXBvc2l0cwogICAgICovCiAgICBkZXBvc2l0KCkgewogICAgICAgIC8vIENvbnRyYWN0IGNhbiByZWNlaXZlIEtMVgogICAgfQp9CgovLyBFeHBvcnQgZm9yIHRlc3RpbmcgYW5kIGRlcGxveW1lbnQKaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7CiAgICBtb2R1bGUuZXhwb3J0cyA9IEtQRVBFSmFja3BvdDsKfQo=",
    "gasLimit": 3000000,
    "gasPrice": 1000000
  },
  "setupFunctions": [
    {
      "fn": "initializeWallets",
      "params": [
        "0x20Ca27aCD025b72a72b1Db0a4268EDF9B900582c",
        "0x20Ca27aCD025b72a72b1Db0a4268EDF9B900582c"
      ],
      "description": "Set project and prize pool wallets"
    },
    {
      "fn": "setKpepeToken",
      "params": [
        "0xEd008768c922b9e2c30a4d666a37bB7dA45Ed5df"
      ],
      "description": "Set KPEPE token address"
    },
    {
      "fn": "setKpepeStaking",
      "params": [
        "0x0000000000000000000000000000000000000000"
      ],
      "description": "Set staking contract address"
    },
    {
      "fn": "toggleRound",
      "params": [],
      "description": "Start the lottery (roundActive = true)"
    }
  ]
}